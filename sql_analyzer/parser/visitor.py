"""
Lark Visitor for traversing the SQL Abstract Syntax Tree (AST).

This visitor identifies specific statement types (e.g., SELECT, CREATE TABLE)
and database objects (e.g., tables, views, databases) within the AST generated
by the Lark parser. It collaborates with the `AnalysisEngine` to record these findings.
"""

from lark import Visitor, Tree, Token
from typing import List, Dict, Any, TYPE_CHECKING, Optional
import logging

if TYPE_CHECKING:
    from sql_analyzer.analysis.engine import AnalysisEngine

logger = logging.getLogger(__name__) # Module-level logger

# List of destructive statement types to track
DESTRUCTIVE_STATEMENTS = {
    'DELETE', 'DROP_TABLE', 'DROP_VIEW', 'DROP_DATABASE', 'DROP_SCHEMA', 
    'TRUNCATE_TABLE', 'TRUNCATE', 'CREATE_OR_REPLACE_TABLE', 'CREATE_OR_REPLACE_VIEW',
    'ALTER_TABLE_DROP_COLUMN', 'UPDATE', 'DROP',
    # Add specific replacements
    'REPLACE'
}

class SQLVisitor(Visitor[Token]): # Inherit from Visitor[Token] for better type hinting
    """Traverses the SQL AST generated by Lark to identify statements and objects.

    It extracts information about statement types and database object references,
    calling methods on the provided `AnalysisEngine` instance to record the findings.

    Attributes:
        engine: An instance of `AnalysisEngine` to record findings.
        current_file: The path of the file currently being processed.
    """
    
    def __init__(self, engine: 'AnalysisEngine'):
        """Initializes the visitor with a reference to the analysis engine."""
        self.engine: 'AnalysisEngine' = engine
        self.current_file: str = ""
        self.debug = False  # Set to True to enable debug output
        
    def _debug(self, msg):
        """Print debug message if debug mode is enabled."""
        if self.debug:
            print(msg)
            
    def _debug_tree(self, tree: Tree | Token, prefix: str = "Node") -> None:
        """Logs the structure of a Tree or Token node for debugging if log level is DEBUG.

        Args:
            tree: The Lark Tree or Token to log.
            prefix: A string prefix for the log message.
        """
        if logger.isEnabledFor(logging.DEBUG):
            def _format_node(node: Tree | Token | Any, indent: int = 0) -> str:
                indent_str = "  " * indent
                if isinstance(node, Tree):
                    children_str = "".join([_format_node(child, indent + 1) for child in node.children])
                    return f"{indent_str}{node.data}\n{children_str}"
                elif isinstance(node, Token):
                    # Escape potential newlines in token values for cleaner logging
                    value_repr = repr(node.value)
                    return f"{indent_str}TOKEN[{node.type}]: {value_repr}\n"
                else:
                    return f"{indent_str}OTHER: {node}\n"

            tree_dump = _format_node(tree).rstrip() # Remove trailing newline
            logger.debug(f"\n--- {prefix} (File: {self.current_file}) ---\n{tree_dump}\n-------------------\n")

    def _find_first_child_by_name(self, tree: Tree, name: str) -> Optional[Tree]:
        """Find the first direct child Tree node with the given `data` attribute name.

        Args:
            tree: The parent Tree node whose children to search.
            name: The `data` attribute value to look for in child Tree nodes.

        Returns:
            The first matching child Tree node, or None if not found.
        """
        if not isinstance(tree, Tree):
            return None
        for child in tree.children:
            if isinstance(child, Tree) and hasattr(child, 'data') and child.data == name:
                return child
        return None

    def _extract_qualified_name(self, tree: Tree) -> Optional[str]:
        """Extract the full name (dot-separated identifiers) from a `qualified_name` node.

        Assumes the input `tree` has a `data` attribute equal to 'qualified_name'
        and contains child Tokens of type 'IDENTIFIER'.

        Args:
            tree: The Tree node representing the qualified name.

        Returns:
            A dot-separated string of the identifiers, or None if extraction fails.
        """
        if not isinstance(tree, Tree) or not hasattr(tree, 'data') or tree.data != 'qualified_name':
            logger.warning(f"_extract_qualified_name called on non-qualified_name node: {getattr(tree, 'data', type(tree))}")
            return None

        name_parts = [
            child.value for child in tree.children
            if isinstance(child, Token) and child.type == 'IDENTIFIER'
        ]

        if not name_parts:
            logger.warning(f"No IDENTIFIER tokens found in qualified_name node: {tree}")
            return None

        return ".".join(name_parts)

    def _record_table_reference_in_context(self, table_name: str, action: str, node: Tree | Token) -> None:
        """Record a table reference within the current context (e.g., task).

        If we're processing within a task context, record the dependency between
        the task and the referenced table.

        Args:
            table_name: The name of the referenced table
            action: The action being performed (e.g., 'REFERENCE', 'INSERT', 'UPDATE')
            node: The AST node that contains the table reference
        """
        # First, record the standard object reference
        self.engine.record_object(
            name=table_name,
            obj_type="TABLE",
            action=action,
            node=node,
            file_path=self.current_file
        )
        
        # If we're in a task context, record the dependency between the task and the table
        context = getattr(self, 'current_context', None)
        if context and context['type'] == 'TASK' and context['name']:
            # Record the dependency with the appropriate relationship type based on the action
            relationship_type = action  # Use action as relationship type by default
            self.engine.result.add_dependency(
                "TASK", context['name'],
                "TABLE", table_name,
                relationship_type
            )

    def _record_object_reference(self, obj_name: str, obj_type: str, action: str, node: Tree | Token) -> None:
        """Record an object reference with the correct object type.

        Args:
            obj_name: The name of the referenced object
            obj_type: The type of the object (e.g., 'TABLE', 'STAGE', 'FILE_FORMAT', 'WAREHOUSE')
            action: The action being performed (e.g., 'REFERENCE', 'CREATE', 'DROP')
            node: The AST node that contains the object reference
        """
        # Record the standard object reference with the specified type
        self.engine.record_object(
            name=obj_name,
            obj_type=obj_type,
            action=action,
            node=node,
            file_path=self.current_file
        )
        
        # If we're within a context (e.g., TASK or PIPE), record the dependency between the parent and the object
        context = getattr(self, 'current_context', None)
        if context and context.get('name'):
            parent_type = context.get('type')
            relationship_type = action
            self.engine.result.add_dependency(
                parent_type, context.get('name'),
                obj_type, obj_name,
                relationship_type
            )

    def statement(self, tree: Tree):
        """Intercepts high-level `statement` nodes.

        Delegates the recording of the specific statement type (e.g., SELECT,
        CREATE_TABLE) to the AnalysisEngine, which handles the necessary refinement.
        Lark automatically proceeds to visit the specific statement child node afterwards.
        """
        self._debug_tree(tree, "Statement")
        # The statement node usually contains one child: the specific statement type node
        if tree.children and isinstance(tree.children[0], Tree):
            stmt_node = tree.children[0]
            
            # Map grammar node names to expected statement types
            node_data = stmt_node.data.upper()
            
            # Special handling for DML statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DML_STMT' and isinstance(stmt_node.children[0], Tree):
                dml_child = stmt_node.children[0]
                dml_type = dml_child.data.upper()
                node_data = dml_type
            
            # Special handling for DDL statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DDL_STMT' and isinstance(stmt_node.children[0], Tree):
                ddl_child = stmt_node.children[0]
                ddl_type = ddl_child.data.upper()
                
                # If it's a CREATE, ALTER, or DROP statement, look one more level
                # to get the specific object type
                if ddl_type in ('CREATE_STMT', 'ALTER_STMT', 'DROP_STMT') and ddl_child.children:
                    if isinstance(ddl_child.children[0], Tree):
                        specific_stmt = ddl_child.children[0]
                        node_data = specific_stmt.data.upper()
                        
                        # Check for CREATE OR REPLACE patterns
                        if node_data.startswith('CREATE_') and ddl_child.children[0].children:
                            for child in ddl_child.children[0].children:
                                if isinstance(child, Token) and child.type == 'REPLACE':
                                    # Convert CREATE_TABLE_STMT to CREATE_OR_REPLACE_TABLE
                                    object_type = node_data.replace('CREATE_', '').replace('_STMT', '')
                                    node_data = f'CREATE_OR_REPLACE_{object_type}'
                                    break
                    else:
                        node_data = ddl_type
                else:
                    # Use the DDL child type directly
                    node_data = ddl_type
            
            # Map grammar node types to expected statement types
            stmt_type_mapping = {
                'SELECT_STMT': 'SELECT',
                'CREATE_TABLE_STMT': 'CREATE_TABLE',
                'USE_STMT': 'USE',  # Will be refined by engine.record_statement for specific object type
                'ALTER_TABLE_STMT': 'ALTER_TABLE',
                'DROP_STMT': 'DROP',  # Refined later by object type
                'DROP_TABLE_STMT': 'DROP_TABLE',
                'DROP_VIEW_STMT': 'DROP_VIEW',
                'DROP_DATABASE_STMT': 'DROP_DATABASE',
                'DROP_SCHEMA_STMT': 'DROP_SCHEMA',
                'DROP_TASK_STMT': 'DROP_TASK',
                'CREATE_VIEW_STMT': 'CREATE_VIEW',
                'CREATE_DATABASE_STMT': 'CREATE_DATABASE',
                'CREATE_STAGE_STMT': 'CREATE_STAGE',
                'CREATE_FILE_FORMAT_STMT': 'CREATE_FILE_FORMAT',
                'COPY_INTO_STMT': 'COPY_INTO', # Base type, specific types recorded elsewhere
                'ALTER_WAREHOUSE_STMT': 'ALTER_WAREHOUSE',
                'UPDATE_STMT': 'UPDATE',
                'INSERT_STMT': 'INSERT',
                'DELETE_STMT': 'DELETE',
                'MERGE_STMT': 'MERGE',
                'CREATE_FUNCTION_STMT': 'CREATE_FUNCTION',
                'TRUNCATE_TABLE_STMT': 'TRUNCATE_TABLE',
                'CREATE_OR_REPLACE_TABLE': 'CREATE_OR_REPLACE_TABLE',
                'CREATE_OR_REPLACE_VIEW': 'CREATE_OR_REPLACE_VIEW',
                'CREATE_TASK_STMT': 'CREATE_TASK',
                'ALTER_TASK_STMT': 'ALTER_TASK',
                'EXECUTE_TASK_STMT': 'EXECUTE_TASK',
                'SHOW_STMT': 'SHOW',
                'DESCRIBE_STMT': 'DESCRIBE',
                'CALL_PROCEDURE_STMT': 'CALL',
                'PUT_STMT': 'PUT',
                'BEGIN_STMT': 'BEGIN',
                'COMMIT_STMT': 'COMMIT',
                'ROLLBACK_STMT': 'ROLLBACK',
                'SAVEPOINT_STMT': 'SAVEPOINT',
                'ROLLBACK_TO_SAVEPOINT_STMT': 'ROLLBACK_TO_SAVEPOINT',
                'DECLARE_STMT': 'DECLARE',
                'SET_STMT': 'SET',
                'EXECUTE_IMMEDIATE_STMT': 'EXECUTE_IMMEDIATE',
                # Add more mappings as needed
            }
            
            # Get the mapped statement type or use the original if not found
            stmt_type = stmt_type_mapping.get(node_data, node_data)
            
            # Debug the statement type determination
            logger.debug(f"Statement type mapping: {node_data} -> {stmt_type}")
            
            # Record the mapped statement type in normal counts, skipping any raw _STMT entries
            # Specific visitors handle USE, DROP, and full PIPE DDL
            # Skip generic counts for grammar nodes ending in '_STMT'
            if stmt_type not in ("USE", "DROP") and not stmt_type.endswith('_STMT'):
                self.engine.record_statement(stmt_type, stmt_node, self.current_file)
            
            # Check if this is a destructive statement and record it
            # Note: Destructive recording for DROP_X is handled in the drop_stmt visitor now
            if stmt_type in DESTRUCTIVE_STATEMENTS and not stmt_type.startswith("DROP_"):
                logger.debug(f"Recording destructive statement: {stmt_type}")
                self.engine.record_destructive_statement(stmt_type, stmt_node, self.current_file)
        else:
            logger.warning(f"Unexpected structure for statement node: {tree}")
        # Proceed to visit the specific statement node (e.g., select_stmt)
        # Lark's default behavior handles this, no need for self.visit(stmt_node)

    def select_stmt(self, tree: Tree):
        """Visits `select_stmt` nodes. Extracts table references from the `from_clause`.

        Identifies tables/views referenced in FROM and JOIN clauses.
        Records found objects as 'SELECT' for object interactions.
        Then, manually visits other children (like select_list) to find nested objects.
        """
        self._debug_tree(tree, "Select Statement")
        from_clause = self._find_first_child_by_name(tree, 'from_clause')
        
        # --- Process FROM and JOIN first --- 
        if from_clause:
            # Helper to record a table/view/stage reference
            def record_ref(node: Tree):
                qual_name_node = self._find_first_child_by_name(node, 'qualified_name')
                stage_path_node = self._find_first_child_by_name(node, 'STAGE_PATH')

                ref_name = None
                obj_type = None
                first_token = None

                if qual_name_node:
                    ref_name = self._extract_qualified_name(qual_name_node)
                    first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
                elif stage_path_node:
                    ref_name = stage_path_node.children[0].value if stage_path_node.children else ""
                    first_token = stage_path_node # Use the node itself for location
                
                if not ref_name or not first_token:
                    return # Could not extract name or location info

                # *** Determine object type based on name prefix ***
                if ref_name.startswith('@'):
                    obj_type = "STAGE"
                else:
                    obj_type = "TABLE" # Assume TABLE/VIEW for non-@ names

                # Check if the parent (base_table_ref) has an alias sibling
                is_alias = False
                if hasattr(node, 'parent') and node.parent is not None:
                    siblings = node.parent.children
                    try:
                        node_index = siblings.index(node)
                        if node_index + 1 < len(siblings):
                            next_sibling = siblings[node_index + 1]
                            if isinstance(next_sibling, Token) and next_sibling.type == 'IDENTIFIER':
                                if node_index + 2 >= len(siblings) or not (isinstance(siblings[node_index + 2], Token) and siblings[node_index + 2].type == 'DOT'):
                                    is_alias = True 
                            if node_index > 0 and isinstance(siblings[node_index -1], Token) and siblings[node_index - 1].type == 'AS':
                                is_alias = True
                    except ValueError:
                        pass 
                                
                common_aliases = {"regionsales", "topcustomers", "cte1", "sub"} 
                if isinstance(ref_name, str) and ref_name.lower() in common_aliases:
                    logger.debug(f"Skipping likely alias: {ref_name}")
                    return
                
                if isinstance(ref_name, str) and ref_name.lower() in {"for"}: 
                    logger.debug(f"Skipping likely keyword: {ref_name}")
                    return

                logger.debug(f"Found {obj_type} reference in SELECT/JOIN: {ref_name}")
                # Record as REFERENCE
                self._record_object_reference(ref_name, obj_type, "SELECT", first_token)
                
                # Also record as SELECT for object interactions (only if it's a TABLE)
                if obj_type == "TABLE":
                     self._record_object_reference(ref_name, obj_type, "SELECT", first_token)

            # Process base table/view in FROM clause
            base_table_node = self._find_first_child_by_name(from_clause, 'base_table_ref')
            if base_table_node:
                if self._find_first_child_by_name(base_table_node, 'qualified_name'):
                    record_ref(base_table_node)

            # Process JOIN clauses
            for join_node in from_clause.find_data('join_clause'):
                join_table_node = self._find_first_child_by_name(join_node, 'base_table_ref')
                if join_table_node:
                    if self._find_first_child_by_name(join_table_node, 'qualified_name'):
                        record_ref(join_table_node)
        # --- END Process FROM and JOIN --- 

        # --- Manually visit other children (like select_list, where_clause) --- 
        for child in tree.children:
            # Avoid re-visiting the from_clause we already processed
            if child is not from_clause:
                 # Only visit if it's a Tree, skip Tokens
                 if isinstance(child, Tree):
                     self.visit(child)
        # --- END Manual visit --- 

    def insert_stmt(self, tree: Tree):
        """Visits `insert_stmt` nodes. Extracts the target `qualified_name`.

        Records the found table as 'REFERENCE' for backward compatibility,
        and as 'INSERT' for object interactions.
        Assumes the first qualified_name after INSERT INTO is the target.
        """
        self._debug_tree(tree, "Insert Statement")
        # Find the first qualified_name, which should be the target table
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table reference in INSERT: {table_name}")
                # Record in the current context (e.g., task context)
                self._record_object_reference(table_name, "TABLE", "INSERT", first_token)
        # Recurse into nested SQL (SELECT, VALUES, etc.) to capture dependencies
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

    def create_table_stmt(self, tree: Tree):
        """Visits `create_table_stmt` nodes. Extracts the `qualified_name` of the table.

        Records the found table as 'CREATE' or as 'REPLACE' if it's a CREATE OR REPLACE statement.
        Also ensures CREATE OR REPLACE is tracked as a destructive operation.
        """
        self._debug_tree(tree, "Create Table Statement")
        
        # Check if this is a CREATE OR REPLACE statement
        is_replace = False
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'REPLACE':
                is_replace = True
                break
        
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                # If it's a REPLACE operation, record as such
                action = "REPLACE" if is_replace else "CREATE"
                logger.debug(f"Found table {action}: {table_name}")
                self._record_object_reference(table_name, "TABLE", action, first_token)
                
                # If it's a REPLACE operation, record as destructive
                if is_replace:
                    self.engine.record_destructive_statement("CREATE_OR_REPLACE_TABLE", tree, self.current_file)

    def alter_table_stmt(self, tree: Tree):
        """Visits `alter_table_stmt` nodes. Identifies table alterations.

        Checks for DROP COLUMN operations specifically, and records them as such.
        Records the table being altered and any columns being dropped.
        """
        self._debug_tree(tree, "Alter Table Statement")
        
        # First find the table being altered
        table_ref = self._find_first_child_by_name(tree, 'qualified_name')
        table_name = None
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                # Record the basic ALTER action on the table
                self._record_object_reference(table_name, "TABLE", "ALTER", first_token)
        
        # Check for DROP COLUMN operations - using a more flexible approach
        is_drop_column = False
        column_name = None
        
        # Look for a DROP token followed by a COLUMN token anywhere in the statement
        drop_token_index = None
        for i, child in enumerate(tree.children):
            if isinstance(child, Token) and child.type == 'DROP':
                drop_token_index = i
                break
                
        if drop_token_index is not None and drop_token_index + 1 < len(tree.children):
            # Check if the next token is COLUMN
            next_token = tree.children[drop_token_index + 1]
            if isinstance(next_token, Token) and next_token.type == 'COLUMN':
                is_drop_column = True
                
                # Try to get column name (usually the next token after COLUMN)
                if drop_token_index + 2 < len(tree.children):
                    column_token = tree.children[drop_token_index + 2]
                    if isinstance(column_token, Token):
                        column_name = column_token.value
        
        # Also look for a possible 'drop_column_clause' node which might be present in some grammars
        drop_column_node = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'drop_column_clause':
                drop_column_node = child
                is_drop_column = True
                # Try to extract column name
                for subchild in child.children:
                    if isinstance(subchild, Token) and subchild.type == 'IDENTIFIER':
                        column_name = subchild.value
                        break
                break
        
        if is_drop_column and table_name:
            # Record the DROP_COLUMN action and the column name if found
            action = "DROP_COLUMN"
            if column_name:
                logger.debug(f"Found DROP COLUMN operation on {table_name}.{column_name}")
                # Record specific column drop
                self._record_object_reference(f"{table_name}.{column_name}", "TABLE", action, first_token if first_token else tree.children[0])
                
                # Also record DROP_COLUMN action on the table itself for easier querying
                self._record_object_reference(table_name, "TABLE", action, first_token if first_token else tree.children[0])
                
                # Always record that this is a destructive action
                self.engine.record_destructive_statement("ALTER_TABLE_DROP_COLUMN", tree, self.current_file)
            else:
                logger.debug(f"Found DROP COLUMN operation on {table_name} but couldn't identify column name")
                # Still record as destructive even if we can't identify the column
                self._record_object_reference(table_name, "TABLE", action, first_token if first_token else tree.children[0])

    def create_view_stmt(self, tree: Tree):
        """Visits `create_view_stmt` nodes. Extracts the `qualified_name` of the view.

        Records the found view as 'CREATE' or as 'REPLACE' if it's a CREATE OR REPLACE statement.
        Also ensures CREATE OR REPLACE is tracked as a destructive operation.
        The underlying SELECT statement (and its references) are visited automatically by Lark.
        """
        # The underlying SELECT statement (and its references) will be visited automatically.
        self._debug_tree(tree, "Create View Statement")
        
        # Check if this is a CREATE OR REPLACE statement
        is_replace = False
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'REPLACE':
                is_replace = True
                break
                
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            view_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if view_name and first_token:
                # If it's a REPLACE operation, record as such
                action = "REPLACE" if is_replace else "CREATE"
                logger.debug(f"Found view {action}: {view_name}")
                self._record_object_reference(view_name, "VIEW", action, first_token)
                
                # If it's a REPLACE operation, record as destructive
                if is_replace:
                    self.engine.record_destructive_statement("CREATE_OR_REPLACE_VIEW", tree, self.current_file)

    def create_database_stmt(self, tree: Tree):
        """Visits `create_database_stmt` nodes. Extracts the `qualified_name` of the database.

        Records the found database as 'CREATE'.
        """
        self._debug_tree(tree, "Create Database Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            db_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if db_name and first_token:
                logger.debug(f"Found database creation: {db_name}")
                self._record_object_reference(db_name, "DATABASE", "CREATE", first_token)

    def alter_warehouse_stmt(self, tree: Tree):
        """Visits `alter_warehouse_stmt` nodes. Extracts the `qualified_name` of the warehouse.

        Records the found warehouse as 'ALTER'.
        """
        self._debug_tree(tree, "Alter Warehouse Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            wh_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if wh_name and first_token:
                logger.debug(f"Found warehouse alteration: {wh_name}")
                self._record_object_reference(wh_name, "WAREHOUSE", "ALTER", first_token)

    def update_stmt(self, tree: Tree):
        """Visits `update_stmt` nodes. Extracts table references.

        Identifies the table being updated in UPDATE statements.
        Records found objects under 'UPDATE' action.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Update Statement")
        
        # Find the table name in the UPDATE clause
        table_ref = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'qualified_name':
                table_ref = child
                break
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table being updated: {table_name}")
                # Record in the current context (e.g., task context)
                self._record_object_reference(table_name, "TABLE", "UPDATE", first_token)
                
                # Make sure to record the UPDATE destructive statement
                self.engine.record_destructive_statement("UPDATE", tree, self.current_file)
                # Recurse into nested SQL (expressions, where clauses) to capture dependencies
                for child in tree.children:
                    if isinstance(child, Tree):
                        self.visit(child)

    def drop_stmt(self, tree: Tree):
        """Visits `drop_stmt` nodes. Extracts the object being dropped.

        Identifies the database object being dropped (e.g., TABLE, VIEW, TASK).
        Records found objects under appropriate 'DROP' action.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Drop Statement")
        
        # Determine the object type being dropped by finding the relevant token
        obj_type = None
        obj_type_token = None
        
        # Get all valid object type strings from the grammar's object_type rule
        # These should match the TOKEN TYPES (not values) in the grammar
        valid_object_types = {
            'TABLE', 'VIEW', 'WAREHOUSE', 'TASK', 'STREAM', 'PIPE', 'STAGE',
            'DATABASE', 'SCHEMA', 'PROCEDURE', 'FUNCTION', 'SEQUENCE'
        }
        
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'object_type':
                # Look inside the object_type node for the actual object type token
                for subchild in child.children:
                    if isinstance(subchild, Token) and subchild.type in valid_object_types:
                        obj_type = subchild.type
                        obj_type_token = subchild
                        break
                if obj_type:
                    break
            # Direct token child (older grammar style)
            elif isinstance(child, Token) and child.type in valid_object_types:
                obj_type = child.type
                obj_type_token = child
                break
        
        if not obj_type:
            logger.warning(f"Could not determine object type in DROP statement: {tree.pretty()}")
            # Attempt to infer from the node data if possible (less reliable)
            if tree.data.startswith('drop_') and tree.data.endswith('_stmt'):
                 inferred_type = tree.data.replace('drop_', '').replace('_stmt', '').upper()
                 if inferred_type in valid_object_types:
                      obj_type = inferred_type
                      logger.info(f"Inferred object type '{obj_type}' from node data in DROP statement.")
                 else:
                     return # Still couldn't determine type
            else:
                 return # Exit if type unknown
        
        # Find the object name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            obj_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            # Use the object type token for location if name token isn't found (e.g., only obj type present)
            node_for_loc = first_token if first_token else obj_type_token 
            
            if obj_name and node_for_loc:
                action = "DROP"
                logger.debug(f"Found {obj_type} being dropped: {obj_name}")
                self._record_object_reference(obj_name, obj_type, action, node_for_loc)
                
                # Make sure to record the specific DROP_X destructive statement
                specific_stmt_type = f"DROP_{obj_type}"
                self.engine.record_destructive_statement(specific_stmt_type, tree, self.current_file)
                # Also record the specific statement count here
                logger.debug(f"VISITOR: Recording specific statement type: {specific_stmt_type}")
                self.engine.record_statement(specific_stmt_type, tree, self.current_file)
            else:
                 logger.warning(f"Could not extract name or location token for DROP {obj_type} statement: {tree.pretty()}")
        else:
             logger.warning(f"Could not find qualified_name node in DROP {obj_type} statement: {tree.pretty()}")
        # Recurse into nested SQL (expressions, where clauses) to capture dependencies
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

    def use_stmt(self, tree: Tree):
        """Visits `use_stmt` nodes. Extracts the `object_type` and name.

        Handles both `USE <object_type> <qualified_name>` and `USE ROLE <identifier>`.
        Records the found object as 'USE'.
        """
        logger.debug("VISITOR: Beginning use_stmt method")
        self._debug_tree(tree, "Use Statement")
        obj_type = "UNKNOWN"
        obj_name = None
        first_token = None

        # Check for USE ROLE IDENTIFIER form first
        role_token = None
        identifier_token = None
        for i, child in enumerate(tree.children):
            if isinstance(child, Token) and child.type == 'ROLE':
                role_token = child
                if i + 1 < len(tree.children) and isinstance(tree.children[i+1], Token) and tree.children[i+1].type == 'IDENTIFIER':
                    identifier_token = tree.children[i+1]
                    break

        if role_token and identifier_token:
            obj_type = "ROLE"
            obj_name = identifier_token.value
            first_token = identifier_token
            logger.debug(f"VISITOR: Extracted ROLE usage: {obj_name}")
        else:
            # Handle USE <object_type> <qualified_name> form
            obj_type_node = self._find_first_child_by_name(tree, 'object_type')
            if obj_type_node and obj_type_node.children and isinstance(obj_type_node.children[0], Token):
                obj_type = obj_type_node.children[0].value.upper()
                logger.debug(f"VISITOR: Extracted object_type = {obj_type}")

            qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
            if qual_name_node:
                obj_name = self._extract_qualified_name(qual_name_node)
                first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
                if obj_name:
                    logger.debug(f"VISITOR: Extracted object name = {obj_name}")
                else:
                     logger.warning(f"VISITOR: Failed to extract object name from qualified_name: {qual_name_node}")
            else:
                logger.warning(f"VISITOR: Failed to find qualified_name node in non-ROLE use_stmt")

        # Record the object if we found name and type
        if obj_name and first_token and obj_type != "UNKNOWN":
            logger.debug(f"VISITOR: Recording USE action for {obj_type}: {obj_name}")
            self._record_object_reference(obj_name, obj_type, "USE", first_token)
            # Record the specific statement type
            self.engine.record_statement(f"USE_{obj_type}", tree, self.current_file)
        else:
            logger.warning(f"VISITOR: Could not record USE statement - Missing name, token, or type. Name: {obj_name}, Type: {obj_type}, Token found: {first_token is not None}")

    def create_function_stmt(self, tree: Tree):
        """Visits `create_function_stmt` nodes. Extracts the function name.

        Records the found function as 'CREATE'.
        """
        self._debug_tree(tree, "Create Function Statement")
        # The function name is usually the first qualified_name encountered directly
        # Need to be careful as arguments might also contain names
        # Let's find the qualified_name that isn't part of an argument_def
        func_name_node = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'qualified_name':
                # Crude check: Assume the first one not nested too deep is the name
                # A better approach might involve checking the parent chain if grammar is complex
                func_name_node = child 
                break 
            elif isinstance(child, Token) and child.type == 'IDENTIFIER': # Handle case where name isn't wrapped in qualified_name? Maybe not needed by grammar.
                 # Handle simple identifier name if grammar allows?
                 pass
        
        if func_name_node:
            func_name = self._extract_qualified_name(func_name_node)
            first_token = next((t for t in func_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                logger.debug(f"Found function creation: {func_name}")
                self._record_object_reference(func_name, "FUNCTION", "CREATE", first_token)
        else:
             logger.warning(f"Could not reliably determine function name in create_function_stmt: {tree.pretty()}")

    def function_call(self, tree: Tree):
        """Visits `function_call` nodes. Extracts the function name.
        
        Records the found function as 'REFERENCE', excluding common built-ins.
        Uses the function name node for location info.
        """
        logger.debug(f"VISITOR: Entering function_call method for node: {tree.pretty()[:100]}...") # Added debug
        self._debug_tree(tree, "Function Call")
        # Function name is typically the qualified_name child
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            func_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                # Avoid logging built-in functions like CURRENT_TIMESTAMP etc. unless desired
                # Basic check: skip common SQL functions (can be expanded)
                # Convert func_name to upper for case-insensitive comparison
                if func_name.upper() not in [
                    'CURRENT_TIMESTAMP', 'DATEADD', 'LEFT', 
                    'RIGHT', 'SUBSTR', 'UPPER', 'LOWER', 'TRIM', 
                    'SUM', 'COUNT', 'AVG', 'MIN', 'MAX', 'CAST', 'TRY_CAST'
                ]: # Add more as needed
                     logger.debug(f"Found function reference: {func_name}")
                     self._record_object_reference(func_name, "FUNCTION", "REFERENCE", first_token)
                else:
                    logger.debug(f"Skipping common/built-in function reference: {func_name}")
        else:
            logger.warning(f"Could not find qualified_name in function_call node: {tree.pretty()}")

    def delete_stmt(self, tree: Tree):
        """Visits `delete_stmt` nodes. Extracts table references.

        Identifies tables targeted by DELETE statements.
        Records found objects as 'DELETE'.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Delete Statement")
        
        # Find the table name in DELETE FROM clause
        table_ref = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'delete_from_clause':
                for subchild in child.children:
                    if isinstance(subchild, Tree) and subchild.data == 'qualified_name':
                        table_ref = subchild
                        break
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table targeted by DELETE: {table_name}")
                self._record_object_reference(table_name, "TABLE", "DELETE", first_token)
                
                # Make sure to record the DELETE destructive statement
                self.engine.record_destructive_statement("DELETE", tree, self.current_file)
                # Recurse into nested SQL (expressions, where clauses) to capture dependencies
                for child in tree.children:
                    if isinstance(child, Tree):
                        self.visit(child)

    def truncate_stmt(self, tree: Tree):
        """Visits `truncate_stmt` nodes. Extracts table references.

        Identifies tables targeted by TRUNCATE statements.
        Records found objects as 'TRUNCATE'.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Truncate Statement")
        
        # Find the table name in TRUNCATE TABLE clause
        table_ref = self._find_first_child_by_name(tree, 'qualified_name')
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table targeted by TRUNCATE: {table_name}")
                self._record_object_reference(table_name, "TABLE", "TRUNCATE", first_token)
                
                # Make sure to record the TRUNCATE_TABLE destructive statement
                self.engine.record_destructive_statement("TRUNCATE_TABLE", tree, self.current_file)

    def create_stage_stmt(self, tree: Tree):
        """Visits `create_stage_stmt` nodes. Extracts the stage name and options."""
        self._debug_tree(tree, "Create Stage Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            stage_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if stage_name and first_token:
                self._record_object_reference(stage_name, "STAGE", "CREATE", first_token)
        # Extract FILE_FORMAT and URL references if present
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'stage_param':
                # Iterate through tokens/nodes within stage_param
                param_children = child.children
                i = 0
                while i < len(param_children):
                    param = param_children[i]
                    if isinstance(param, Tree) and param.data == 'file_format_option':
                        # Handle inline file format options (e.g., TYPE = 'CSV')
                        option_name_token = None
                        for subparam in param.children:
                            if isinstance(subparam, Token) and subparam.type == 'IDENTIFIER':
                                option_name_token = subparam
                                break # Found the identifier token
                        if option_name_token:
                            self._record_object_reference(option_name_token.value, "OPTION", "REFERENCE", option_name_token)
                        i += 1 # Move past the file_format_option node
                    elif isinstance(param, Token) and param.type == 'FILE_FORMAT':
                        # Handle named file format reference (e.g., FILE_FORMAT = my_fmt)
                        # Expect EQ and qualified_name next
                        if i + 2 < len(param_children) and isinstance(param_children[i+1], Token) and param_children[i+1].type == 'EQ':
                            ff_node = param_children[i+2]
                            if isinstance(ff_node, Tree) and ff_node.data == 'qualified_name':
                                ff_name = self._extract_qualified_name(ff_node)
                                ff_token = next((t for t in ff_node.children if isinstance(t, Token)), None)
                                if ff_name and ff_token:
                                    self._record_object_reference(ff_name, "FILE_FORMAT", "REFERENCE", ff_token)
                                i += 3 # Move past FILE_FORMAT, EQ, qualified_name
                            else:
                                i += 1 # Move past FILE_FORMAT if structure unexpected
                        else:
                           i += 1 # Move past FILE_FORMAT if structure unexpected
                    elif isinstance(param, Token) and param.type == 'URL':
                        # Handle URL parameter
                        if i + 2 < len(param_children) and isinstance(param_children[i+1], Token) and param_children[i+1].type == 'EQ':
                             url_node = param_children[i+2]
                             # Assuming URL value is a token (e.g., SINGLE_QUOTED_STRING)
                             if isinstance(url_node, Token):
                                 self._record_object_reference(stage_name, "STAGE", "URL_REFERENCE", url_node)
                                 i += 3 # Move past URL, EQ, value
                             else:
                                i += 1 # Move past URL if structure unexpected
                        else:
                            i += 1 # Move past URL if structure unexpected
                    else:
                        # Unknown/unhandled parameter token/node
                        i += 1

    def create_file_format_stmt(self, tree: Tree):
        """Visits `create_file_format_stmt` nodes. Extracts the file format name and options."""
        self._debug_tree(tree, "Create File Format Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            format_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if format_name and first_token:
                self._record_object_reference(format_name, "FILE_FORMAT", "CREATE", first_token)
        # Extract TYPE and file format options
        type_value = None
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'TYPE':
                type_value = child.value
            elif isinstance(child, Tree) and child.data == 'file_format_option_kv':
                for param in child.children:
                    if isinstance(param, Token) and param.type == 'FIELD_DELIMITER':
                        self._record_object_reference(format_name, "FILE_FORMAT", "FIELD_DELIMITER", param)
        if type_value:
            self._record_object_reference(format_name, "FILE_FORMAT", f"TYPE_{type_value}", first_token)

    def copy_into_stmt(self, tree: Tree):
        """Visits `copy_into_stmt` nodes. Extracts source and target for COPY INTO, and options."""
        self._debug_tree(tree, "Copy Into Statement")

        copy_target_node = self._find_first_child_by_name(tree, 'copy_target')
        target_recorded = False
        target_name_str = None
        target_type = None
        target_node_for_loc = None

        if copy_target_node:
            qual_name_node = self._find_first_child_by_name(copy_target_node, 'qualified_name')
            stage_path_node = self._find_first_child_by_name(copy_target_node, 'STAGE_PATH')

            if qual_name_node:
                target_name_str = self._extract_qualified_name(qual_name_node)
                target_node_for_loc = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            elif stage_path_node:
                target_name_str = stage_path_node.children[0].value if stage_path_node.children else ""
                target_node_for_loc = stage_path_node
            
            if target_name_str and target_node_for_loc:
                # *** Determine target type based on name prefix ***
                if target_name_str.startswith('@'):
                    target_type = "STAGE"
                    self._record_object_reference(target_name_str, "STAGE", "COPY_INTO_STAGE", target_node_for_loc)
                    # Also record as a reference for source/target (if it's the target)
                    self._record_object_reference(target_name_str, "STAGE", "REFERENCE", target_node_for_loc)
                    # Record the specific statement count
                    self.engine.record_statement("COPY_INTO_STAGE", tree, self.current_file)
                else:
                    target_type = "TABLE"
                    self._record_object_reference(target_name_str, "TABLE", "COPY_INTO_TABLE", target_node_for_loc)
                    # Record the specific statement count
                    self.engine.record_statement("COPY_INTO_TABLE", tree, self.current_file)
                target_recorded = True
        
        if not target_recorded:
             logger.warning(f"Could not determine target (TABLE or STAGE) in COPY INTO statement: {tree.pretty()}")

        # --- Process Copy Source ---
        copy_source_node = self._find_first_child_by_name(tree, 'copy_source')
        if copy_source_node:
            source_qual_name_node = self._find_first_child_by_name(copy_source_node, 'qualified_name')
            source_stage_path_node = self._find_first_child_by_name(copy_source_node, 'STAGE_PATH')
            source_select_node = self._find_first_child_by_name(copy_source_node, 'select_stmt')

            source_name_str = None
            source_type = None
            source_node_for_loc = None

            if source_qual_name_node:
                source_name_str = self._extract_qualified_name(source_qual_name_node)
                source_node_for_loc = next((t for t in source_qual_name_node.children if isinstance(t, Token)), None)
            elif source_stage_path_node:
                source_name_str = source_stage_path_node.children[0].value if source_stage_path_node.children else ""
                source_node_for_loc = source_stage_path_node
            
            if source_name_str and source_node_for_loc:
                 # *** Determine source type based on name prefix ***
                 if source_name_str.startswith('@'):
                     source_type = "STAGE"
                     self._record_object_reference(source_name_str, "STAGE", "REFERENCE", source_node_for_loc)
                 else:
                     source_type = "TABLE"
                     self._record_object_reference(source_name_str, "TABLE", "REFERENCE", source_node_for_loc)
            elif source_select_node:
                # If source is a subquery, visit it to find references within
                logger.debug("Descending into SELECT statement within COPY INTO source...")
                self.visit(source_select_node)

        # --- Process Copy Options (e.g., FILE_FORMAT reference) ---
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'copy_option':
                file_format_clause = self._find_first_child_by_name(child, 'file_format_clause')
                if file_format_clause:
                    # Look for a qualified_name (direct reference) first
                    ff_qual_name_node = self._find_first_child_by_name(file_format_clause, 'qualified_name')
                    if ff_qual_name_node:
                         file_format_name = self._extract_qualified_name(ff_qual_name_node)
                         first_token = next((t for t in ff_qual_name_node.children if isinstance(t, Token)), None)
                         if file_format_name and first_token:
                            self._record_object_reference(file_format_name, "FILE_FORMAT", "REFERENCE", first_token)
                    else:
                        # Look for IDENTIFIER within file_format_option (inline definition case)
                        # This part might need refinement based on exact grammar for inline options
                        # Check if FORMAT_NAME = IDENTIFIER exists
                        for option_node in file_format_clause.find_data('file_format_option'):
                             # Assuming structure: IDENTIFIER EQ value
                             id_token = None
                             val_token = None
                             eq_found = False
                             for item in option_node.children:
                                 if isinstance(item, Token) and item.type == 'IDENTIFIER':
                                     id_token = item
                                 elif isinstance(item, Token) and item.type == 'EQ':
                                     eq_found = True
                                 elif id_token and eq_found:
                                     # Capture identifier or quoted string as value
                                     if isinstance(item, Token) and item.type in ('IDENTIFIER', 'SINGLE_QUOTED_STRING'):
                                         val_token = item
                                         break
                             if id_token and id_token.value.upper() == 'FORMAT_NAME' and val_token:
                                 # Extract unquoted format name
                                 if val_token.type == 'SINGLE_QUOTED_STRING':
                                     fmt_name = val_token.value.strip("'")
                                 else:
                                     fmt_name = val_token.value
                                 self._record_object_reference(fmt_name, "FILE_FORMAT", "REFERENCE", val_token)
                                 break # Found the format name reference

        # Optionally, extract ON_ERROR etc. from other copy_option children

    def create_task_stmt(self, tree: Tree):
        """Visits `create_task_stmt` nodes. Extracts the task name, warehouse, schedule, dependencies, and SQL body."""
        self._debug_tree(tree, "Create Task Statement")
        
        # Extract task name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        task_name = None
        if qual_name_node:
            task_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if task_name and first_token:
                self._record_object_reference(task_name, "TASK", "CREATE_TASK", first_token)
                self.engine.record_statement("CREATE_TASK", tree, self.current_file)
        
        # Extract referenced warehouse, schedule, dependencies (AFTER)
        referenced_warehouse = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'task_param':
                for param in child.children:
                    if isinstance(param, Token) and param.type == 'WAREHOUSE':
                        # Next child should be the warehouse name
                        idx = child.children.index(param)
                        if idx + 2 < len(child.children):
                            wh_node = child.children[idx + 2]
                            if isinstance(wh_node, Tree) and wh_node.data == 'qualified_name':
                                wh_name = self._extract_qualified_name(wh_node)
                                wh_token = next((t for t in wh_node.children if isinstance(t, Token)), None)
                                if wh_name and wh_token:
                                    # Record warehouse reference
                                    referenced_warehouse = wh_name
                                    self._record_object_reference(wh_name, "WAREHOUSE", "REFERENCE", wh_token)
                    elif isinstance(param, Token) and param.type == 'AFTER':
                        # Find the qualified_name for the dependency task
                        dep_node = None
                        for i in range(child.children.index(param) + 1, len(child.children)):
                            if isinstance(child.children[i], Tree) and child.children[i].data == 'qualified_name':
                                dep_node = child.children[i]
                                break
                        
                        if dep_node:
                            dep_name = self._extract_qualified_name(dep_node)
                            dep_token = next((t for t in dep_node.children if isinstance(t, Token)), None)
                            if dep_name and dep_token:
                                # Record the dependency
                                self._record_object_reference(dep_name, "TASK", "DEPENDENCY", dep_token)
                                
                                # Add explicit AFTER dependency relationship
                                if task_name:
                                    self.engine.result.add_dependency(
                                        "TASK", task_name,
                                        "TASK", dep_name,
                                        "AFTER"
                                    )
        
        # Analyze the SQL statement in the AS clause using a task context to track dependencies
        for child in tree.children:
            # Include the wrapper for WITH clauses (_statement_wrapper)
            if isinstance(child, Tree) and child.data in ('call_procedure_stmt', '_statement', '_statement_wrapper'):
                
                # Record current task name to track SQL dependencies
                old_context = getattr(self, 'current_context', None)
                self.current_context = {
                    'type': 'TASK',
                    'name': task_name,
                    'warehouse': referenced_warehouse
                }
                
                try:
                    # Process the SQL statement
                    self.visit(child)
                finally:
                    # Restore previous context
                    self.current_context = old_context

    def alter_task_stmt(self, tree: Tree):
        """Visits `alter_task_stmt` nodes. Extracts the task name and action."""
        self._debug_tree(tree, "Alter Task Statement")
        
        # Extract task name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        task_name = None
        if qual_name_node:
            task_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if task_name and first_token:
                self._record_object_reference(task_name, "TASK", "ALTER_TASK", first_token)
                self.engine.record_statement("ALTER_TASK", tree, self.current_file)
        
        # Extract referenced warehouse or dependencies
        referenced_warehouse = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'alter_task_action':
                # Check for ADD AFTER or REMOVE AFTER
                for i, param in enumerate(child.children):
                    if isinstance(param, Token):
                        if param.type == 'WAREHOUSE' and i + 2 < len(child.children):
                            # Get warehouse reference
                            wh_node = child.children[i + 2]
                            if isinstance(wh_node, Tree) and wh_node.data == 'qualified_name':
                                wh_name = self._extract_qualified_name(wh_node)
                                wh_token = next((t for t in wh_node.children if isinstance(t, Token)), None)
                                if wh_name and wh_token:
                                    # Record warehouse reference
                                    referenced_warehouse = wh_name
                                    self._record_object_reference(wh_name, "WAREHOUSE", "REFERENCE", wh_token)
                        
                        elif param.type in ('ADD', 'REMOVE') and i + 1 < len(child.children):
                            # Check for AFTER keyword following ADD or REMOVE
                            if isinstance(child.children[i + 1], Token) and child.children[i + 1].type == 'AFTER':
                                # Record multiple dependencies following AFTER
                                j = i + 2
                                while j < len(child.children):
                                    node = child.children[j]
                                    if isinstance(node, Tree) and node.data == 'qualified_name':
                                        dep_name = self._extract_qualified_name(node)
                                        dep_token = next((t for t in node.children if isinstance(t, Token)), None)
                                        if dep_name and dep_token:
                                            # Record the dependency action
                                            self._record_object_reference(dep_name, "TASK", "DEPENDENCY", dep_token)
                                            if task_name:
                                                # Distinguish between added vs removed AFTER
                                                if param.type == 'ADD':
                                                    relation = "ADDED_AFTER"
                                                else:
                                                    relation = "REMOVED_AFTER"
                                                self.engine.result.add_dependency(
                                                    "TASK", task_name,
                                                    "TASK", dep_name,
                                                    relation
                                                )
                                    j += 1
        
        # If MODIFY AS, analyze the SQL statement 
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'alter_task_action':
                for i, param in enumerate(child.children):
                    if isinstance(param, Token) and param.type == 'MODIFY' and i + 1 < len(child.children):
                        if isinstance(child.children[i + 1], Token) and child.children[i + 1].type == 'AS':
                            # Find the SQL statement
                            for j in range(i + 2, len(child.children)):
                                if isinstance(child.children[j], Tree) and child.children[j].data in ('call_procedure_stmt', '_statement', '_statement_wrapper'):
                                    # Record current task name to track SQL dependencies
                                    old_context = getattr(self, 'current_context', None)
                                    self.current_context = {
                                        'type': 'TASK',
                                        'name': task_name,
                                        'warehouse': referenced_warehouse
                                    }
                                    
                                    try:
                                        # Process the SQL statement
                                        self.visit(child.children[j])
                                    finally:
                                        # Restore previous context
                                        self.current_context = old_context

    def execute_task_stmt(self, tree: Tree):
        """Visits `execute_task_stmt` nodes. Extracts the task name and records EXECUTE_TASK action."""
        self._debug_tree(tree, "Execute Task Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            task_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if task_name and first_token:
                self._record_object_reference(task_name, "TASK", "EXECUTE_TASK", first_token)
                self.engine.record_statement("EXECUTE_TASK", tree, self.current_file)

    def call_procedure_stmt(self, tree: Tree):
        """Visits `call_procedure_stmt` nodes. Extracts the procedure name."""
        self._debug_tree(tree, "Call Procedure Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            proc_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if proc_name and first_token:
                self.engine.record_object(
                    name=proc_name,
                    obj_type="PROCEDURE",
                    action="CALL",
                    node=first_token,
                    file_path=self.current_file
                )
                
                # If in task context, record dependency between task and procedure
                context = getattr(self, 'current_context', None)
                if context and context['type'] == 'TASK' and context['name']:
                    self.engine.result.add_dependency(
                        "TASK", context['name'],
                        "PROCEDURE", proc_name,
                        "CALL"
                    )

    def merge_stmt(self, tree: Tree):
        """Visits `merge_stmt` nodes. Extracts table references.

        Identifies target table (MERGE INTO) and source table (USING).
        Records target table as 'UPDATE' action and source as 'SELECT' action.
        """
        self._debug_tree(tree, "Merge Statement")
        
        # Extract target table (MERGE INTO <target_table>)
        target_table_node = self._find_first_child_by_name(tree, 'qualified_name')
        if target_table_node:
            target_table = self._extract_qualified_name(target_table_node)
            target_token = next((t for t in target_table_node.children if isinstance(t, Token)), None)
            if target_table and target_token:
                logger.debug(f"Found target table in MERGE: {target_table}")
                # Record UPDATE action before handling delete clauses
                self._record_object_reference(target_table, "TABLE", "UPDATE", target_token)
        
        # Extract source table (USING <source_table>)
        # Find the base_table_ref after the USING keyword
        source_node = None
        for i, child in enumerate(tree.children):
            if isinstance(child, Token) and child.type == 'USING' and i+1 < len(tree.children):
                source_node = tree.children[i+1]
                break
        
        if source_node and isinstance(source_node, Tree) and source_node.data == 'base_table_ref':
            # Process the source table reference
            qual_name_node = self._find_first_child_by_name(source_node, 'qualified_name')
            if qual_name_node:
                source_table = self._extract_qualified_name(qual_name_node)
                first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
                if source_table and first_token:
                    logger.debug(f"Found source table in MERGE: {source_table}")
                    self._record_object_reference(source_table, "TABLE", "SELECT", first_token)
        
        # Record DELETE action for MERGE WHEN MATCHED THEN DELETE clauses
        for delete_clause in tree.find_data('merge_delete_clause'):
            if target_table and target_token:
                logger.debug(f"Recording DELETE action for target table in MERGE delete clause: {target_table}")
                self._record_object_reference(target_table, "TABLE", "DELETE", target_token)

        # Visit child nodes to process any subqueries
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

    def create_stream_stmt(self, tree: Tree):
        """Visits `create_stream_stmt` nodes. Extracts the stream name, base object, and parameters."""
        self._debug_tree(tree, "Create Stream Statement")
        # Extract stream name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        stream_name = None
        if qual_name_node:
            stream_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if stream_name and first_token:
                self._record_object_reference(stream_name, "STREAM", "CREATE_STREAM", first_token)
                self.engine.record_statement("CREATE_STREAM", tree, self.current_file)
        # Extract base table or stage reference (second qualified_name)
        qual_nodes = [c for c in tree.children if isinstance(c, Tree) and c.data == 'qualified_name']
        if len(qual_nodes) >= 2:
            base_node = qual_nodes[1]
            base_name = self._extract_qualified_name(base_node)
            base_token = next((t for t in base_node.children if isinstance(t, Token)), None)
            # Determine base type from preceding token
            base_type = None
            idx = tree.children.index(base_node)
            if idx >= 1 and isinstance(tree.children[idx-1], Token):
                if tree.children[idx-1].type in ('TABLE', 'STAGE'):
                    base_type = tree.children[idx-1].type
            if base_name and base_token and base_type:
                self._record_object_reference(base_name, base_type, "REFERENCE", base_token)
        # Extract at_before_clause parameters
        at_clause = self._find_first_child_by_name(tree, 'at_before_clause')
        if at_clause:
            for param in at_clause.find_data('at_before_param'):
                first_token = param.children[0] if param.children else None
                if isinstance(first_token, Token) and stream_name:
                    param_name = first_token.value.upper()
                    self._record_object_reference(stream_name, "STREAM", param_name, first_token)

    def alter_stream_stmt(self, tree: Tree):
        """Visits `alter_stream_stmt` nodes. Extracts the stream name and updated parameters."""
        self._debug_tree(tree, "Alter Stream Statement")
        # Extract stream name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        stream_name = None
        if qual_name_node:
            stream_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if stream_name and first_token:
                self._record_object_reference(stream_name, "STREAM", "ALTER_STREAM", first_token)
                self.engine.record_statement("ALTER_STREAM", tree, self.current_file)
        # Extract stream parameters (could be nested within stream_set_clause)
        for param in tree.find_data('stream_param'):
            param_token = param.children[0] if param.children else None
            if isinstance(param_token, Token) and stream_name:
                param_name = param_token.value.upper()
                self._record_object_reference(stream_name, "STREAM", param_name, param_token)

    def create_pipe_stmt(self, tree: Tree):
        """Visits `create_pipe_stmt` nodes. Extracts the pipe name, parameters, and embedded COPY INTO statement."""
        self._debug_tree(tree, "Create Pipe Statement")
        # Extract pipe name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        pipe_name = None
        if qual_name_node:
            pipe_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if pipe_name and first_token:
                self._record_object_reference(pipe_name, "PIPE", "CREATE_PIPE", first_token)
                self.engine.record_statement("CREATE_PIPE", tree, self.current_file)
        # Extract pipe parameters
        for param in tree.find_data('pipe_param'):
            param_token = param.children[0] if param.children else None
            if isinstance(param_token, Token) and pipe_name:
                param_name = param_token.type
                self._record_object_reference(pipe_name, "PIPE", param_name, param_token)
        # Visit embedded COPY INTO statement within the pipe
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'copy_into_stmt':
                old_context = getattr(self, 'current_context', None)
                self.current_context = {'type': 'PIPE', 'name': pipe_name}
                try:
                    self.visit(child)
                finally:
                    self.current_context = old_context

    def alter_pipe_stmt(self, tree: Tree):
        """Visits `alter_pipe_stmt` nodes. Extracts the pipe name and updated parameters."""
        self._debug_tree(tree, "Alter Pipe Statement")
        # Extract pipe name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        pipe_name = None
        first_token = None
        if qual_name_node:
            pipe_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
        # Determine if this is a SET alter or a REFRESH alter
        has_set = any(isinstance(child, Token) and child.type == 'SET' for child in tree.children)
        # Only count SET variant as ALTER_PIPE statement
        if pipe_name and first_token and has_set:
            self._record_object_reference(pipe_name, "PIPE", "ALTER_PIPE", first_token)
            self.engine.record_statement("ALTER_PIPE", tree, self.current_file)
        # Record REFRESH as an object action, do not count as ALTER_PIPE
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'REFRESH' and pipe_name:
                self._record_object_reference(pipe_name, "PIPE", "REFRESH", child)
        # Extract updated pipe parameters (common to SET variant)
        for param in tree.find_data('pipe_param'):
            param_token = param.children[0] if param.children else None
            if isinstance(param_token, Token) and pipe_name:
                param_name = param_token.type
                self._record_object_reference(pipe_name, "PIPE", param_name, param_token)

    # Add more specific visitor methods here for other statements/constructs
    # E.g., insert_stmt, merge_stmt, function calls, etc.

    # If a rule like `qualified_name`