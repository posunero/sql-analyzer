"""
Lark Visitor for traversing the SQL Abstract Syntax Tree (AST).

This visitor identifies specific statement types (e.g., SELECT, CREATE TABLE)
and database objects (e.g., tables, views, databases) within the AST generated
by the Lark parser. It collaborates with the `AnalysisEngine` to record these findings.
"""

from lark import Visitor, Tree, Token
from typing import List, Dict, Any, TYPE_CHECKING, Optional
import logging

if TYPE_CHECKING:
    from sql_analyzer.analysis.engine import AnalysisEngine

logger = logging.getLogger(__name__) # Module-level logger

class SQLVisitor(Visitor[Token]): # Inherit from Visitor[Token] for better type hinting
    """Traverses the SQL AST generated by Lark to identify statements and objects.

    It extracts information about statement types and database object references,
    calling methods on the provided `AnalysisEngine` instance to record the findings.

    Attributes:
        engine: An instance of `AnalysisEngine` to record findings.
        current_file: The path of the file currently being processed.
    """
    
    def __init__(self, engine: 'AnalysisEngine'):
        """Initializes the visitor with a reference to the analysis engine."""
        self.engine: 'AnalysisEngine' = engine
        self.current_file: str = ""
        self.debug = False  # Set to True to enable debug output
        
    def _debug(self, msg):
        """Print debug message if debug mode is enabled."""
        if self.debug:
            print(msg)
            
    def _debug_tree(self, tree: Tree | Token, prefix: str = "Node") -> None:
        """Logs the structure of a Tree or Token node for debugging if log level is DEBUG.

        Args:
            tree: The Lark Tree or Token to log.
            prefix: A string prefix for the log message.
        """
        if logger.isEnabledFor(logging.DEBUG):
            def _format_node(node: Tree | Token | Any, indent: int = 0) -> str:
                indent_str = "  " * indent
                if isinstance(node, Tree):
                    children_str = "".join([_format_node(child, indent + 1) for child in node.children])
                    return f"{indent_str}{node.data}\n{children_str}"
                elif isinstance(node, Token):
                    # Escape potential newlines in token values for cleaner logging
                    value_repr = repr(node.value)
                    return f"{indent_str}TOKEN[{node.type}]: {value_repr}\n"
                else:
                    return f"{indent_str}OTHER: {node}\n"

            tree_dump = _format_node(tree).rstrip() # Remove trailing newline
            logger.debug(f"\n--- {prefix} (File: {self.current_file}) ---\n{tree_dump}\n-------------------\n")

    def _find_first_child_by_name(self, tree: Tree, name: str) -> Optional[Tree]:
        """Find the first direct child Tree node with the given `data` attribute name.

        Args:
            tree: The parent Tree node whose children to search.
            name: The `data` attribute value to look for in child Tree nodes.

        Returns:
            The first matching child Tree node, or None if not found.
        """
        if not isinstance(tree, Tree):
            return None
        for child in tree.children:
            if isinstance(child, Tree) and hasattr(child, 'data') and child.data == name:
                return child
        return None

    def _extract_qualified_name(self, tree: Tree) -> Optional[str]:
        """Extract the full name (dot-separated identifiers) from a `qualified_name` node.

        Assumes the input `tree` has a `data` attribute equal to 'qualified_name'
        and contains child Tokens of type 'IDENTIFIER'.

        Args:
            tree: The Tree node representing the qualified name.

        Returns:
            A dot-separated string of the identifiers, or None if extraction fails.
        """
        if not isinstance(tree, Tree) or not hasattr(tree, 'data') or tree.data != 'qualified_name':
            logger.warning(f"_extract_qualified_name called on non-qualified_name node: {getattr(tree, 'data', type(tree))}")
            return None

        name_parts = [
            child.value for child in tree.children
            if isinstance(child, Token) and child.type == 'IDENTIFIER'
        ]

        if not name_parts:
            logger.warning(f"No IDENTIFIER tokens found in qualified_name node: {tree}")
            return None

        return ".".join(name_parts)

    def statement(self, tree: Tree):
        """Intercepts high-level `statement` nodes.

        Delegates the recording of the specific statement type (e.g., SELECT,
        CREATE_TABLE) to the AnalysisEngine, which handles the necessary refinement.
        Lark automatically proceeds to visit the specific statement child node afterwards.
        """
        self._debug_tree(tree, "Statement")
        # The statement node usually contains one child: the specific statement type node
        if tree.children and isinstance(tree.children[0], Tree):
            stmt_node = tree.children[0]
            
            # Map grammar node names to expected statement types
            node_data = stmt_node.data.upper()
            
            # Special handling for DML statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DML_STMT' and isinstance(stmt_node.children[0], Tree):
                dml_child = stmt_node.children[0]
                dml_type = dml_child.data.upper()
                node_data = dml_type
            
            # Special handling for DDL statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DDL_STMT' and isinstance(stmt_node.children[0], Tree):
                ddl_child = stmt_node.children[0]
                ddl_type = ddl_child.data.upper()
                
                # If it's a CREATE, ALTER, or DROP statement, look one more level
                # to get the specific object type
                if ddl_type in ('CREATE_STMT', 'ALTER_STMT', 'DROP_STMT') and ddl_child.children:
                    if isinstance(ddl_child.children[0], Tree):
                        specific_stmt = ddl_child.children[0]
                        node_data = specific_stmt.data.upper()
                    else:
                        node_data = ddl_type
                else:
                    # Use the DDL child type directly
                    node_data = ddl_type
            
            # Map grammar node types to expected statement types
            stmt_type_mapping = {
                'SELECT_STMT': 'SELECT',
                'CREATE_TABLE_STMT': 'CREATE_TABLE',
                'USE_STMT': 'USE',  # Will be refined by engine.record_statement for specific object type
                'ALTER_TABLE_STMT': 'ALTER_TABLE',
                'DROP_STMT': 'DROP',  # Refined later by object type
                'DROP_VIEW_STMT': 'DROP_VIEW',
                'DROP_DATABASE_STMT': 'DROP_DATABASE',
                'CREATE_VIEW_STMT': 'CREATE_VIEW',
                'CREATE_DATABASE_STMT': 'CREATE_DATABASE',
                'ALTER_WAREHOUSE_STMT': 'ALTER_WAREHOUSE',
                'UPDATE_STMT': 'UPDATE',
                'INSERT_STMT': 'INSERT',
                'DELETE_STMT': 'DELETE',
                'MERGE_STMT': 'MERGE',
                'CREATE_FUNCTION_STMT': 'CREATE_FUNCTION',
                # Add more mappings as needed
            }
            
            # Get the mapped statement type or use the original if not found
            stmt_type = stmt_type_mapping.get(node_data, node_data)
            
            # Debug the statement type determination
            logger.debug(f"Statement type mapping: {node_data} -> {stmt_type}")
            
            self.engine.record_statement(stmt_type, stmt_node, self.current_file)
        else:
            logger.warning(f"Unexpected structure for statement node: {tree}")
        # Proceed to visit the specific statement node (e.g., select_stmt)
        # Lark's default behavior handles this, no need for self.visit(stmt_node)

    def select_stmt(self, tree: Tree):
        """Visits `select_stmt` nodes. Extracts table references from the `from_clause`.

        Identifies tables/views referenced in FROM and JOIN clauses.
        Records found objects as 'REFERENCE'.
        Then, manually visits other children (like select_list) to find nested objects.
        """
        self._debug_tree(tree, "Select Statement")
        from_clause = self._find_first_child_by_name(tree, 'from_clause')
        
        # --- Process FROM and JOIN first --- 
        if from_clause:
            # Helper to record a table/view reference
            def record_ref(node: Tree):
                qual_name_node = self._find_first_child_by_name(node, 'qualified_name')
                if qual_name_node:
                    table_name = self._extract_qualified_name(qual_name_node)
                    first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
                    if table_name and first_token:
                        # Check if the parent (base_table_ref) has an alias sibling
                        is_alias = False
                        if hasattr(node, 'parent') and node.parent is not None:
                            siblings = node.parent.children
                            try:
                                node_index = siblings.index(node)
                                if node_index + 1 < len(siblings):
                                    next_sibling = siblings[node_index + 1]
                                    if isinstance(next_sibling, Token) and next_sibling.type == 'IDENTIFIER':
                                        if node_index + 2 >= len(siblings) or not (isinstance(siblings[node_index + 2], Token) and siblings[node_index + 2].type == 'DOT'):
                                            is_alias = True 
                                if node_index > 0 and isinstance(siblings[node_index -1], Token) and siblings[node_index - 1].type == 'AS':
                                    is_alias = True
                            except ValueError:
                                pass 
                                
                        common_aliases = {"regionsales", "topcustomers", "cte1", "sub"} 
                        if table_name.lower() in common_aliases:
                            logger.debug(f"Skipping likely alias: {table_name}")
                            return
                        
                        if table_name.lower() in {"for"}: 
                            logger.debug(f"Skipping likely keyword: {table_name}")
                            return

                        logger.debug(f"Found table/view reference in SELECT/JOIN: {table_name}")
                        self.engine.record_object(
                            name=table_name,
                            obj_type="TABLE",
                            action="REFERENCE",
                            node=first_token, 
                            file_path=self.current_file
                        )

            # Process base table/view in FROM clause
            base_table_node = self._find_first_child_by_name(from_clause, 'base_table_ref')
            if base_table_node:
                if self._find_first_child_by_name(base_table_node, 'qualified_name'):
                    record_ref(base_table_node)

            # Process JOIN clauses
            for join_node in from_clause.find_data('join_clause'):
                join_table_node = self._find_first_child_by_name(join_node, 'base_table_ref')
                if join_table_node:
                    if self._find_first_child_by_name(join_table_node, 'qualified_name'):
                        record_ref(join_table_node)
        # --- END Process FROM and JOIN --- 

        # --- Manually visit other children (like select_list, where_clause) --- 
        for child in tree.children:
            # Avoid re-visiting the from_clause we already processed
            if child is not from_clause:
                 # Only visit if it's a Tree, skip Tokens
                 if isinstance(child, Tree):
                     self.visit(child)
        # --- END Manual visit --- 

    def insert_stmt(self, tree: Tree):
        """Visits `insert_stmt` nodes. Extracts the target `qualified_name`.

        Records the found table as 'REFERENCE'.
        Assumes the first qualified_name after INSERT INTO is the target.
        """
        self._debug_tree(tree, "Insert Statement")
        # Find the first qualified_name, which should be the target table
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table reference in INSERT: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="REFERENCE", # Could potentially be "INSERT" action if needed
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        # Currently don't parse the SELECT part of INSERT INTO SELECT
        # or the VALUES part for potential function calls etc.
        # self.visit_children(tree) # Avoid recursion if grammar nests SELECT here

    def create_table_stmt(self, tree: Tree):
        """Visits `create_table_stmt` nodes. Extracts the `qualified_name` of the table.

        Records the found table as 'CREATE'.
        """
        self._debug_tree(tree, "Create Table Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table creation: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        # self.visit_children(tree) # Visit children if needed (e.g., analyze columns)

    def alter_table_stmt(self, tree: Tree):
        """Visits `alter_table_stmt` nodes. Extracts the `qualified_name` of the table.

        Records the found table as 'ALTER'.
        """
        self._debug_tree(tree, "Alter Table Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table alteration: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="ALTER",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        # self.visit_children(tree) # Visit children if needed (e.g., analyze actions)

    def create_view_stmt(self, tree: Tree):
        """Visits `create_view_stmt` nodes. Extracts the `qualified_name` of the view.

        Records the found view as 'CREATE'. The underlying SELECT statement (and its
        references) are visited automatically by Lark.
        """
        # The underlying SELECT statement (and its references) will be visited automatically.
        self._debug_tree(tree, "Create View Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            view_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if view_name and first_token:
                logger.debug(f"Found view creation: {view_name}")
                self.engine.record_object(
                    name=view_name,
                    obj_type="VIEW",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def create_database_stmt(self, tree: Tree):
        """Visits `create_database_stmt` nodes. Extracts the `qualified_name` of the database.

        Records the found database as 'CREATE'.
        """
        self._debug_tree(tree, "Create Database Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            db_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if db_name and first_token:
                logger.debug(f"Found database creation: {db_name}")
                self.engine.record_object(
                    name=db_name,
                    obj_type="DATABASE",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def alter_warehouse_stmt(self, tree: Tree):
        """Visits `alter_warehouse_stmt` nodes. Extracts the `qualified_name` of the warehouse.

        Records the found warehouse as 'ALTER'.
        """
        self._debug_tree(tree, "Alter Warehouse Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            wh_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if wh_name and first_token:
                logger.debug(f"Found warehouse alteration: {wh_name}")
                self.engine.record_object(
                    name=wh_name,
                    obj_type="WAREHOUSE",
                    action="ALTER",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def update_stmt(self, tree: Tree):
        """Visits `update_stmt` nodes. Extracts the primary `qualified_name` (target table).

        Records the found table as 'UPDATE'. Does not currently parse WHERE clauses
        or SET expressions for additional references.
        """
        self._debug_tree(tree, "Update Statement")
        # The first qualified_name is typically the table being updated
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table update: {table_name}")
                # Record the primary table being updated
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="UPDATE", # Could be refined based on grammar if needed
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        # TODO: Potentially find table references in WHERE clause or SET expressions
        # self.visit_children(tree)

    def drop_stmt(self, tree: Tree):
        """Visits `drop_stmt` nodes. Extracts the `object_type` and `qualified_name`.

        Determines the object type (TABLE, VIEW, etc.) from the `object_type` child node.
        Records the found object as 'DROP'.
        """
        self._debug_tree(tree, "Drop Statement")
        obj_type = "UNKNOWN"
        obj_type_node = self._find_first_child_by_name(tree, 'object_type')
        if obj_type_node and obj_type_node.children and isinstance(obj_type_node.children[0], Token):
            obj_type = obj_type_node.children[0].value.upper()

        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            obj_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if obj_name and first_token:
                logger.debug(f"Found {obj_type} drop: {obj_name}")
                self.engine.record_object(
                    name=obj_name,
                    obj_type=obj_type,
                    action="DROP",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def use_stmt(self, tree: Tree):
        """Visits `use_stmt` nodes. Extracts the `object_type` and `qualified_name`.

        Determines the object type (WAREHOUSE, DATABASE, etc.) from the `object_type` child node.
        Records the found object as 'USE'.
        """
        # print("VISITOR: Inside use_stmt visitor method") # Keep commented out unless needed
        logger.debug("VISITOR: Beginning use_stmt method")
        self._debug_tree(tree, "Use Statement")
        obj_type = "UNKNOWN"
        obj_type_node = self._find_first_child_by_name(tree, 'object_type')
        if obj_type_node and obj_type_node.children and isinstance(obj_type_node.children[0], Token):
            obj_type = obj_type_node.children[0].value.upper()
            logger.debug(f"VISITOR: Extracted object_type = {obj_type}")

        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            obj_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if obj_name and first_token:
                logger.debug(f"VISITOR: Found {obj_type} use: {obj_name}")
                self.engine.record_object(
                    name=obj_name,
                    obj_type=obj_type,
                    action="USE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
            else:
                logger.warning(f"VISITOR: Failed to extract object name from qualified_name: {qual_name_node}")
        else:
            logger.warning(f"VISITOR: Failed to find qualified_name node in use_stmt")

    def create_function_stmt(self, tree: Tree):
        """Visits `create_function_stmt` nodes. Extracts the function name.

        Records the found function as 'CREATE'.
        """
        self._debug_tree(tree, "Create Function Statement")
        # The function name is usually the first qualified_name encountered directly
        # Need to be careful as arguments might also contain names
        # Let's find the qualified_name that isn't part of an argument_def
        func_name_node = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'qualified_name':
                # Crude check: Assume the first one not nested too deep is the name
                # A better approach might involve checking the parent chain if grammar is complex
                func_name_node = child 
                break 
            elif isinstance(child, Token) and child.type == 'IDENTIFIER': # Handle case where name isn't wrapped in qualified_name? Maybe not needed by grammar.
                 # Handle simple identifier name if grammar allows?
                 pass
        
        if func_name_node:
            func_name = self._extract_qualified_name(func_name_node)
            first_token = next((t for t in func_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                logger.debug(f"Found function creation: {func_name}")
                self.engine.record_object(
                    name=func_name,
                    obj_type="FUNCTION",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        else:
             logger.warning(f"Could not reliably determine function name in create_function_stmt: {tree.pretty()}")

    def function_call(self, tree: Tree):
        """Visits `function_call` nodes. Extracts the function name.
        
        Records the found function as 'REFERENCE', excluding common built-ins.
        Uses the function name node for location info.
        """
        logger.debug(f"VISITOR: Entering function_call method for node: {tree.pretty()[:100]}...") # Added debug
        self._debug_tree(tree, "Function Call")
        # Function name is typically the qualified_name child
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            func_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                # Avoid logging built-in functions like CURRENT_TIMESTAMP etc. unless desired
                # Basic check: skip common SQL functions (can be expanded)
                # Convert func_name to upper for case-insensitive comparison
                if func_name.upper() not in [
                    'CURRENT_TIMESTAMP', 'DATEADD', 'LEFT', 
                    'RIGHT', 'SUBSTR', 'UPPER', 'LOWER', 'TRIM', 
                    'SUM', 'COUNT', 'AVG', 'MIN', 'MAX', 'CAST', 'TRY_CAST'
                ]: # Add more as needed
                     logger.debug(f"Found function reference: {func_name}")
                     self.engine.record_object(
                        name=func_name,
                        obj_type="FUNCTION",
                        action="REFERENCE",
                        node=first_token, # Pass the specific token
                        file_path=self.current_file
                    )
                else:
                    logger.debug(f"Skipping common/built-in function reference: {func_name}")
        else:
            logger.warning(f"Could not find qualified_name in function_call node: {tree.pretty()}")

    # Add more specific visitor methods here for other statements/constructs
    # E.g., insert_stmt, merge_stmt, function calls, etc.

    # If a rule like `qualified_name`