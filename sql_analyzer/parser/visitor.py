"""
Lark Visitor for traversing the SQL Abstract Syntax Tree (AST).

This visitor identifies specific statement types (e.g., SELECT, CREATE TABLE)
and database objects (e.g., tables, views, databases) within the AST generated
by the Lark parser. It collaborates with the `AnalysisEngine` to record these findings.
"""

from lark import Visitor, Tree, Token
from typing import List, Dict, Any, TYPE_CHECKING, Optional
import logging

if TYPE_CHECKING:
    from sql_analyzer.analysis.engine import AnalysisEngine

logger = logging.getLogger(__name__) # Module-level logger

# List of destructive statement types to track
DESTRUCTIVE_STATEMENTS = {
    'DELETE', 'DROP_TABLE', 'DROP_VIEW', 'DROP_DATABASE', 'DROP_SCHEMA', 
    'TRUNCATE_TABLE', 'TRUNCATE', 'CREATE_OR_REPLACE_TABLE', 'CREATE_OR_REPLACE_VIEW',
    'ALTER_TABLE_DROP_COLUMN', 'UPDATE', 'DROP',
    # Add specific replacements
    'REPLACE'
}

class SQLVisitor(Visitor[Token]): # Inherit from Visitor[Token] for better type hinting
    """Traverses the SQL AST generated by Lark to identify statements and objects.

    It extracts information about statement types and database object references,
    calling methods on the provided `AnalysisEngine` instance to record the findings.

    Attributes:
        engine: An instance of `AnalysisEngine` to record findings.
        current_file: The path of the file currently being processed.
    """
    
    def __init__(self, engine: 'AnalysisEngine'):
        """Initializes the visitor with a reference to the analysis engine."""
        self.engine: 'AnalysisEngine' = engine
        self.current_file: str = ""
        self.debug = False  # Set to True to enable debug output
        
    def _debug(self, msg):
        """Print debug message if debug mode is enabled."""
        if self.debug:
            print(msg)
            
    def _debug_tree(self, tree: Tree | Token, prefix: str = "Node") -> None:
        """Logs the structure of a Tree or Token node for debugging if log level is DEBUG.

        Args:
            tree: The Lark Tree or Token to log.
            prefix: A string prefix for the log message.
        """
        if logger.isEnabledFor(logging.DEBUG):
            def _format_node(node: Tree | Token | Any, indent: int = 0) -> str:
                indent_str = "  " * indent
                if isinstance(node, Tree):
                    children_str = "".join([_format_node(child, indent + 1) for child in node.children])
                    return f"{indent_str}{node.data}\n{children_str}"
                elif isinstance(node, Token):
                    # Escape potential newlines in token values for cleaner logging
                    value_repr = repr(node.value)
                    return f"{indent_str}TOKEN[{node.type}]: {value_repr}\n"
                else:
                    return f"{indent_str}OTHER: {node}\n"

            tree_dump = _format_node(tree).rstrip() # Remove trailing newline
            logger.debug(f"\n--- {prefix} (File: {self.current_file}) ---\n{tree_dump}\n-------------------\n")

    def _find_first_child_by_name(self, tree: Tree, name: str) -> Optional[Tree]:
        """Find the first direct child Tree node with the given `data` attribute name.

        Args:
            tree: The parent Tree node whose children to search.
            name: The `data` attribute value to look for in child Tree nodes.

        Returns:
            The first matching child Tree node, or None if not found.
        """
        if not isinstance(tree, Tree):
            return None
        for child in tree.children:
            if isinstance(child, Tree) and hasattr(child, 'data') and child.data == name:
                return child
        return None

    def _extract_qualified_name(self, tree: Tree) -> Optional[str]:
        """Extract the full name (dot-separated identifiers) from a `qualified_name` node.

        Assumes the input `tree` has a `data` attribute equal to 'qualified_name'
        and contains child Tokens of type 'IDENTIFIER'.

        Args:
            tree: The Tree node representing the qualified name.

        Returns:
            A dot-separated string of the identifiers, or None if extraction fails.
        """
        if not isinstance(tree, Tree) or not hasattr(tree, 'data') or tree.data != 'qualified_name':
            logger.warning(f"_extract_qualified_name called on non-qualified_name node: {getattr(tree, 'data', type(tree))}")
            return None

        name_parts = [
            child.value for child in tree.children
            if isinstance(child, Token) and child.type == 'IDENTIFIER'
        ]

        if not name_parts:
            logger.warning(f"No IDENTIFIER tokens found in qualified_name node: {tree}")
            return None

        return ".".join(name_parts)

    def statement(self, tree: Tree):
        """Intercepts high-level `statement` nodes.

        Delegates the recording of the specific statement type (e.g., SELECT,
        CREATE_TABLE) to the AnalysisEngine, which handles the necessary refinement.
        Lark automatically proceeds to visit the specific statement child node afterwards.
        """
        self._debug_tree(tree, "Statement")
        # The statement node usually contains one child: the specific statement type node
        if tree.children and isinstance(tree.children[0], Tree):
            stmt_node = tree.children[0]
            
            # Map grammar node names to expected statement types
            node_data = stmt_node.data.upper()
            
            # Special handling for DML statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DML_STMT' and isinstance(stmt_node.children[0], Tree):
                dml_child = stmt_node.children[0]
                dml_type = dml_child.data.upper()
                node_data = dml_type
            
            # Special handling for DDL statements - inspect one level deeper
            # to get more specific statement type
            if node_data == 'DDL_STMT' and isinstance(stmt_node.children[0], Tree):
                ddl_child = stmt_node.children[0]
                ddl_type = ddl_child.data.upper()
                
                # If it's a CREATE, ALTER, or DROP statement, look one more level
                # to get the specific object type
                if ddl_type in ('CREATE_STMT', 'ALTER_STMT', 'DROP_STMT') and ddl_child.children:
                    if isinstance(ddl_child.children[0], Tree):
                        specific_stmt = ddl_child.children[0]
                        node_data = specific_stmt.data.upper()
                        
                        # Check for CREATE OR REPLACE patterns
                        if node_data.startswith('CREATE_') and ddl_child.children[0].children:
                            for child in ddl_child.children[0].children:
                                if isinstance(child, Token) and child.type == 'REPLACE':
                                    # Convert CREATE_TABLE_STMT to CREATE_OR_REPLACE_TABLE
                                    object_type = node_data.replace('CREATE_', '').replace('_STMT', '')
                                    node_data = f'CREATE_OR_REPLACE_{object_type}'
                                    break
                    else:
                        node_data = ddl_type
                else:
                    # Use the DDL child type directly
                    node_data = ddl_type
            
            # Map grammar node types to expected statement types
            stmt_type_mapping = {
                'SELECT_STMT': 'SELECT',
                'CREATE_TABLE_STMT': 'CREATE_TABLE',
                'USE_STMT': 'USE',  # Will be refined by engine.record_statement for specific object type
                'ALTER_TABLE_STMT': 'ALTER_TABLE',
                'DROP_STMT': 'DROP',  # Refined later by object type
                'DROP_TABLE_STMT': 'DROP_TABLE',
                'DROP_VIEW_STMT': 'DROP_VIEW',
                'DROP_DATABASE_STMT': 'DROP_DATABASE',
                'DROP_SCHEMA_STMT': 'DROP_SCHEMA',
                'CREATE_VIEW_STMT': 'CREATE_VIEW',
                'CREATE_DATABASE_STMT': 'CREATE_DATABASE',
                'CREATE_STAGE_STMT': 'CREATE_STAGE',
                'CREATE_FILE_FORMAT_STMT': 'CREATE_FILE_FORMAT',
                'COPY_INTO_STMT': 'COPY_INTO', # Base type, specific types recorded elsewhere
                'ALTER_WAREHOUSE_STMT': 'ALTER_WAREHOUSE',
                'UPDATE_STMT': 'UPDATE',
                'INSERT_STMT': 'INSERT',
                'DELETE_STMT': 'DELETE',
                'MERGE_STMT': 'MERGE',
                'CREATE_FUNCTION_STMT': 'CREATE_FUNCTION',
                'TRUNCATE_TABLE_STMT': 'TRUNCATE_TABLE',
                'CREATE_OR_REPLACE_TABLE': 'CREATE_OR_REPLACE_TABLE',
                'CREATE_OR_REPLACE_VIEW': 'CREATE_OR_REPLACE_VIEW',
                # Add more mappings as needed
            }
            
            # Get the mapped statement type or use the original if not found
            stmt_type = stmt_type_mapping.get(node_data, node_data)
            
            # Debug the statement type determination
            logger.debug(f"Statement type mapping: {node_data} -> {stmt_type}")
            
            # Record the mapped statement type in normal counts
            # Specific visitors might record more detailed counts later (e.g., COPY_INTO_TABLE)
            self.engine.record_statement(stmt_type, stmt_node, self.current_file)
            
            # Check if this is a destructive statement and record it
            if stmt_type in DESTRUCTIVE_STATEMENTS:
                logger.debug(f"Recording destructive statement: {stmt_type}")
                self.engine.record_destructive_statement(stmt_type, stmt_node, self.current_file)
        else:
            logger.warning(f"Unexpected structure for statement node: {tree}")
        # Proceed to visit the specific statement node (e.g., select_stmt)
        # Lark's default behavior handles this, no need for self.visit(stmt_node)

    def select_stmt(self, tree: Tree):
        """Visits `select_stmt` nodes. Extracts table references from the `from_clause`.

        Identifies tables/views referenced in FROM and JOIN clauses.
        Records found objects as 'SELECT' for object interactions.
        Then, manually visits other children (like select_list) to find nested objects.
        """
        self._debug_tree(tree, "Select Statement")
        from_clause = self._find_first_child_by_name(tree, 'from_clause')
        
        # --- Process FROM and JOIN first --- 
        if from_clause:
            # Helper to record a table/view/stage reference
            def record_ref(node: Tree):
                qual_name_node = self._find_first_child_by_name(node, 'qualified_name')
                stage_path_node = self._find_first_child_by_name(node, 'STAGE_PATH')

                ref_name = None
                obj_type = None
                first_token = None

                if qual_name_node:
                    ref_name = self._extract_qualified_name(qual_name_node)
                    first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
                elif stage_path_node:
                    ref_name = stage_path_node.children[0].value if stage_path_node.children else ""
                    first_token = stage_path_node # Use the node itself for location
                
                if not ref_name or not first_token:
                    return # Could not extract name or location info

                # *** Determine object type based on name prefix ***
                if ref_name.startswith('@'):
                    obj_type = "STAGE"
                else:
                    obj_type = "TABLE" # Assume TABLE/VIEW for non-@ names

                # Check if the parent (base_table_ref) has an alias sibling
                is_alias = False
                if hasattr(node, 'parent') and node.parent is not None:
                    siblings = node.parent.children
                    try:
                        node_index = siblings.index(node)
                        if node_index + 1 < len(siblings):
                            next_sibling = siblings[node_index + 1]
                            if isinstance(next_sibling, Token) and next_sibling.type == 'IDENTIFIER':
                                if node_index + 2 >= len(siblings) or not (isinstance(siblings[node_index + 2], Token) and siblings[node_index + 2].type == 'DOT'):
                                    is_alias = True 
                            if node_index > 0 and isinstance(siblings[node_index -1], Token) and siblings[node_index - 1].type == 'AS':
                                is_alias = True
                    except ValueError:
                        pass 
                                
                common_aliases = {"regionsales", "topcustomers", "cte1", "sub"} 
                if isinstance(ref_name, str) and ref_name.lower() in common_aliases:
                    logger.debug(f"Skipping likely alias: {ref_name}")
                    return
                
                if isinstance(ref_name, str) and ref_name.lower() in {"for"}: 
                    logger.debug(f"Skipping likely keyword: {ref_name}")
                    return

                logger.debug(f"Found {obj_type} reference in SELECT/JOIN: {ref_name}")
                # Record as REFERENCE
                self.engine.record_object(
                    name=ref_name,
                    obj_type=obj_type,
                    action="REFERENCE",
                    node=first_token, 
                    file_path=self.current_file
                )
                
                # Also record as SELECT for object interactions (only if it's a TABLE)
                if obj_type == "TABLE":
                     self.engine.record_object(
                         name=ref_name,
                         obj_type="TABLE",
                         action="SELECT",
                         node=first_token, 
                         file_path=self.current_file
                     )

            # Process base table/view in FROM clause
            base_table_node = self._find_first_child_by_name(from_clause, 'base_table_ref')
            if base_table_node:
                if self._find_first_child_by_name(base_table_node, 'qualified_name'):
                    record_ref(base_table_node)

            # Process JOIN clauses
            for join_node in from_clause.find_data('join_clause'):
                join_table_node = self._find_first_child_by_name(join_node, 'base_table_ref')
                if join_table_node:
                    if self._find_first_child_by_name(join_table_node, 'qualified_name'):
                        record_ref(join_table_node)
        # --- END Process FROM and JOIN --- 

        # --- Manually visit other children (like select_list, where_clause) --- 
        for child in tree.children:
            # Avoid re-visiting the from_clause we already processed
            if child is not from_clause:
                 # Only visit if it's a Tree, skip Tokens
                 if isinstance(child, Tree):
                     self.visit(child)
        # --- END Manual visit --- 

    def insert_stmt(self, tree: Tree):
        """Visits `insert_stmt` nodes. Extracts the target `qualified_name`.

        Records the found table as 'REFERENCE' for backward compatibility,
        and as 'INSERT' for object interactions.
        Assumes the first qualified_name after INSERT INTO is the target.
        """
        self._debug_tree(tree, "Insert Statement")
        # Find the first qualified_name, which should be the target table
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table reference in INSERT: {table_name}")
                # Record as REFERENCE for backward compatibility
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="REFERENCE",
                    node=first_token,
                    file_path=self.current_file
                )
                
                # Also record as INSERT for object interactions
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="INSERT",
                    node=first_token,
                    file_path=self.current_file
                )
        # Currently don't parse the SELECT part of INSERT INTO SELECT
        # or the VALUES part for potential function calls etc.
        # self.visit_children(tree) # Avoid recursion if grammar nests SELECT here

    def create_table_stmt(self, tree: Tree):
        """Visits `create_table_stmt` nodes. Extracts the `qualified_name` of the table.

        Records the found table as 'CREATE' or as 'REPLACE' if it's a CREATE OR REPLACE statement.
        Also ensures CREATE OR REPLACE is tracked as a destructive operation.
        """
        self._debug_tree(tree, "Create Table Statement")
        
        # Check if this is a CREATE OR REPLACE statement
        is_replace = False
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'REPLACE':
                is_replace = True
                break
        
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            table_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if table_name and first_token:
                # If it's a REPLACE operation, record as such
                action = "REPLACE" if is_replace else "CREATE"
                logger.debug(f"Found table {action}: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action=action,
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
                
                # If it's a REPLACE operation, record as destructive
                if is_replace:
                    self.engine.record_destructive_statement("CREATE_OR_REPLACE_TABLE", tree, self.current_file)

    def alter_table_stmt(self, tree: Tree):
        """Visits `alter_table_stmt` nodes. Identifies table alterations.

        Checks for DROP COLUMN operations specifically, and records them as such.
        Records the table being altered and any columns being dropped.
        """
        self._debug_tree(tree, "Alter Table Statement")
        
        # First find the table being altered
        table_ref = self._find_first_child_by_name(tree, 'qualified_name')
        table_name = None
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                # Record the basic ALTER action on the table
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="ALTER",
                    node=first_token,
                    file_path=self.current_file
                )
        
        # Check for DROP COLUMN operations - using a more flexible approach
        is_drop_column = False
        column_name = None
        
        # Look for a DROP token followed by a COLUMN token anywhere in the statement
        drop_token_index = None
        for i, child in enumerate(tree.children):
            if isinstance(child, Token) and child.type == 'DROP':
                drop_token_index = i
                break
                
        if drop_token_index is not None and drop_token_index + 1 < len(tree.children):
            # Check if the next token is COLUMN
            next_token = tree.children[drop_token_index + 1]
            if isinstance(next_token, Token) and next_token.type == 'COLUMN':
                is_drop_column = True
                
                # Try to get column name (usually the next token after COLUMN)
                if drop_token_index + 2 < len(tree.children):
                    column_token = tree.children[drop_token_index + 2]
                    if isinstance(column_token, Token):
                        column_name = column_token.value
        
        # Also look for a possible 'drop_column_clause' node which might be present in some grammars
        drop_column_node = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'drop_column_clause':
                drop_column_node = child
                is_drop_column = True
                # Try to extract column name
                for subchild in child.children:
                    if isinstance(subchild, Token) and subchild.type == 'IDENTIFIER':
                        column_name = subchild.value
                        break
                break
        
        if is_drop_column and table_name:
            # Record the DROP_COLUMN action and the column name if found
            action = "DROP_COLUMN"
            if column_name:
                logger.debug(f"Found DROP COLUMN operation on {table_name}.{column_name}")
                # Record specific column drop
                self.engine.record_object(
                    name=f"{table_name}.{column_name}",
                    obj_type="COLUMN",
                    action=action,
                    node=first_token if first_token else tree.children[0],
                    file_path=self.current_file
                )
                
                # Also record DROP_COLUMN action on the table itself for easier querying
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action=action,
                    node=first_token if first_token else tree.children[0],
                    file_path=self.current_file
                )
                
                # Always record that this is a destructive action
                self.engine.record_destructive_statement("ALTER_TABLE_DROP_COLUMN", tree, self.current_file)
            else:
                logger.debug(f"Found DROP COLUMN operation on {table_name} but couldn't identify column name")
                # Still record as destructive even if we can't identify the column
                self.engine.record_destructive_statement("ALTER_TABLE_DROP_COLUMN", tree, self.current_file)

    def create_view_stmt(self, tree: Tree):
        """Visits `create_view_stmt` nodes. Extracts the `qualified_name` of the view.

        Records the found view as 'CREATE' or as 'REPLACE' if it's a CREATE OR REPLACE statement.
        Also ensures CREATE OR REPLACE is tracked as a destructive operation.
        The underlying SELECT statement (and its references) are visited automatically by Lark.
        """
        # The underlying SELECT statement (and its references) will be visited automatically.
        self._debug_tree(tree, "Create View Statement")
        
        # Check if this is a CREATE OR REPLACE statement
        is_replace = False
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'REPLACE':
                is_replace = True
                break
                
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            view_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if view_name and first_token:
                # If it's a REPLACE operation, record as such
                action = "REPLACE" if is_replace else "CREATE"
                logger.debug(f"Found view {action}: {view_name}")
                self.engine.record_object(
                    name=view_name,
                    obj_type="VIEW",
                    action=action,
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
                
                # If it's a REPLACE operation, record as destructive
                if is_replace:
                    self.engine.record_destructive_statement("CREATE_OR_REPLACE_VIEW", tree, self.current_file)

    def create_database_stmt(self, tree: Tree):
        """Visits `create_database_stmt` nodes. Extracts the `qualified_name` of the database.

        Records the found database as 'CREATE'.
        """
        self._debug_tree(tree, "Create Database Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            db_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if db_name and first_token:
                logger.debug(f"Found database creation: {db_name}")
                self.engine.record_object(
                    name=db_name,
                    obj_type="DATABASE",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def alter_warehouse_stmt(self, tree: Tree):
        """Visits `alter_warehouse_stmt` nodes. Extracts the `qualified_name` of the warehouse.

        Records the found warehouse as 'ALTER'.
        """
        self._debug_tree(tree, "Alter Warehouse Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            wh_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if wh_name and first_token:
                logger.debug(f"Found warehouse alteration: {wh_name}")
                self.engine.record_object(
                    name=wh_name,
                    obj_type="WAREHOUSE",
                    action="ALTER",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )

    def update_stmt(self, tree: Tree):
        """Visits `update_stmt` nodes. Extracts table references.

        Identifies the table being updated in UPDATE statements.
        Records found objects under 'UPDATE' action.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Update Statement")
        
        # Find the table name in the UPDATE clause
        table_ref = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'qualified_name':
                table_ref = child
                break
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table being updated: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="UPDATE",
                    node=first_token,
                    file_path=self.current_file
                )
                
                # Make sure to record the UPDATE destructive statement
                self.engine.record_destructive_statement("UPDATE", tree, self.current_file)

    def drop_stmt(self, tree: Tree):
        """Visits `drop_stmt` nodes. Extracts the object being dropped.

        Identifies the database object being dropped (e.g., TABLE, VIEW).
        Records found objects under appropriate 'DROP' action.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Drop Statement")
        
        # Determine the object type being dropped
        obj_type = None
        for child in tree.children:
            if isinstance(child, Token) and child.type in ('TABLE', 'VIEW', 'DATABASE', 'SCHEMA'):
                obj_type = child.value.upper()
                break
        
        if not obj_type:
            logger.warning("Could not determine object type in DROP statement")
            return
        
        # Find the object name
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            obj_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if obj_name and first_token:
                action = "DROP"
                logger.debug(f"Found {obj_type} being dropped: {obj_name}")
                self.engine.record_object(
                    name=obj_name,
                    obj_type=obj_type,
                    action=action,
                    node=first_token,
                    file_path=self.current_file
                )
                
                # Make sure to record the specific DROP_X destructive statement
                specific_stmt_type = f"DROP_{obj_type}"
                self.engine.record_destructive_statement(specific_stmt_type, tree, self.current_file)

    def use_stmt(self, tree: Tree):
        """Visits `use_stmt` nodes. Extracts the `object_type` and `qualified_name`.

        Determines the object type (WAREHOUSE, DATABASE, etc.) from the `object_type` child node.
        Records the found object as 'USE'.
        """
        # print("VISITOR: Inside use_stmt visitor method") # Keep commented out unless needed
        logger.debug("VISITOR: Beginning use_stmt method")
        self._debug_tree(tree, "Use Statement")
        obj_type = "UNKNOWN"
        obj_type_node = self._find_first_child_by_name(tree, 'object_type')
        if obj_type_node and obj_type_node.children and isinstance(obj_type_node.children[0], Token):
            obj_type = obj_type_node.children[0].value.upper()
            logger.debug(f"VISITOR: Extracted object_type = {obj_type}")

        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            obj_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if obj_name and first_token:
                logger.debug(f"VISITOR: Found {obj_type} use: {obj_name}")
                self.engine.record_object(
                    name=obj_name,
                    obj_type=obj_type,
                    action="USE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
            else:
                logger.warning(f"VISITOR: Failed to extract object name from qualified_name: {qual_name_node}")
        else:
            logger.warning(f"VISITOR: Failed to find qualified_name node in use_stmt")

    def create_function_stmt(self, tree: Tree):
        """Visits `create_function_stmt` nodes. Extracts the function name.

        Records the found function as 'CREATE'.
        """
        self._debug_tree(tree, "Create Function Statement")
        # The function name is usually the first qualified_name encountered directly
        # Need to be careful as arguments might also contain names
        # Let's find the qualified_name that isn't part of an argument_def
        func_name_node = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'qualified_name':
                # Crude check: Assume the first one not nested too deep is the name
                # A better approach might involve checking the parent chain if grammar is complex
                func_name_node = child 
                break 
            elif isinstance(child, Token) and child.type == 'IDENTIFIER': # Handle case where name isn't wrapped in qualified_name? Maybe not needed by grammar.
                 # Handle simple identifier name if grammar allows?
                 pass
        
        if func_name_node:
            func_name = self._extract_qualified_name(func_name_node)
            first_token = next((t for t in func_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                logger.debug(f"Found function creation: {func_name}")
                self.engine.record_object(
                    name=func_name,
                    obj_type="FUNCTION",
                    action="CREATE",
                    node=first_token, # Pass the specific token
                    file_path=self.current_file
                )
        else:
             logger.warning(f"Could not reliably determine function name in create_function_stmt: {tree.pretty()}")

    def function_call(self, tree: Tree):
        """Visits `function_call` nodes. Extracts the function name.
        
        Records the found function as 'REFERENCE', excluding common built-ins.
        Uses the function name node for location info.
        """
        logger.debug(f"VISITOR: Entering function_call method for node: {tree.pretty()[:100]}...") # Added debug
        self._debug_tree(tree, "Function Call")
        # Function name is typically the qualified_name child
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            func_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if func_name and first_token:
                # Avoid logging built-in functions like CURRENT_TIMESTAMP etc. unless desired
                # Basic check: skip common SQL functions (can be expanded)
                # Convert func_name to upper for case-insensitive comparison
                if func_name.upper() not in [
                    'CURRENT_TIMESTAMP', 'DATEADD', 'LEFT', 
                    'RIGHT', 'SUBSTR', 'UPPER', 'LOWER', 'TRIM', 
                    'SUM', 'COUNT', 'AVG', 'MIN', 'MAX', 'CAST', 'TRY_CAST'
                ]: # Add more as needed
                     logger.debug(f"Found function reference: {func_name}")
                     self.engine.record_object(
                        name=func_name,
                        obj_type="FUNCTION",
                        action="REFERENCE",
                        node=first_token, # Pass the specific token
                        file_path=self.current_file
                    )
                else:
                    logger.debug(f"Skipping common/built-in function reference: {func_name}")
        else:
            logger.warning(f"Could not find qualified_name in function_call node: {tree.pretty()}")

    def delete_stmt(self, tree: Tree):
        """Visits `delete_stmt` nodes. Extracts table references.

        Identifies tables targeted by DELETE statements.
        Records found objects as 'DELETE'.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Delete Statement")
        
        # Find the table name in DELETE FROM clause
        table_ref = None
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'delete_from_clause':
                for subchild in child.children:
                    if isinstance(subchild, Tree) and subchild.data == 'qualified_name':
                        table_ref = subchild
                        break
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table targeted by DELETE: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="DELETE",
                    node=first_token,
                    file_path=self.current_file
                )
                
                # Make sure to record the DELETE destructive statement
                self.engine.record_destructive_statement("DELETE", tree, self.current_file)

    def truncate_stmt(self, tree: Tree):
        """Visits `truncate_stmt` nodes. Extracts table references.

        Identifies tables targeted by TRUNCATE statements.
        Records found objects as 'TRUNCATE'.
        Also ensures the destructive statement is recorded.
        """
        self._debug_tree(tree, "Truncate Statement")
        
        # Find the table name in TRUNCATE TABLE clause
        table_ref = self._find_first_child_by_name(tree, 'qualified_name')
        
        if table_ref:
            table_name = self._extract_qualified_name(table_ref)
            first_token = next((t for t in table_ref.children if isinstance(t, Token)), None)
            if table_name and first_token:
                logger.debug(f"Found table targeted by TRUNCATE: {table_name}")
                self.engine.record_object(
                    name=table_name,
                    obj_type="TABLE",
                    action="TRUNCATE",
                    node=first_token,
                    file_path=self.current_file
                )
                
                # Make sure to record the TRUNCATE_TABLE destructive statement
                self.engine.record_destructive_statement("TRUNCATE_TABLE", tree, self.current_file)

    def create_stage_stmt(self, tree: Tree):
        """Visits `create_stage_stmt` nodes. Extracts the stage name and options."""
        self._debug_tree(tree, "Create Stage Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            stage_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if stage_name and first_token:
                self.engine.record_object(
                    name=stage_name,
                    obj_type="STAGE",
                    action="CREATE",
                    node=first_token,
                    file_path=self.current_file
                )
        # Extract FILE_FORMAT and URL references if present
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'stage_param':
                for param in child.children:
                    if isinstance(param, Tree) and param.data == 'file_format_option':
                        # This is a FILE_FORMAT reference
                        file_format_name = None
                        for subparam in param.children:
                            if isinstance(subparam, Token) and subparam.type == 'IDENTIFIER':
                                file_format_name = subparam.value
                        if file_format_name:
                            self.engine.record_object(
                                name=file_format_name,
                                obj_type="FILE_FORMAT",
                                action="REFERENCE",
                                node=param,
                                file_path=self.current_file
                            )
                    elif isinstance(param, Token) and param.type == 'URL':
                        self.engine.record_object(
                            name=stage_name,
                            obj_type="STAGE",
                            action="URL",
                            node=param,
                            file_path=self.current_file
                        )

    def create_file_format_stmt(self, tree: Tree):
        """Visits `create_file_format_stmt` nodes. Extracts the file format name and options."""
        self._debug_tree(tree, "Create File Format Statement")
        qual_name_node = self._find_first_child_by_name(tree, 'qualified_name')
        if qual_name_node:
            format_name = self._extract_qualified_name(qual_name_node)
            first_token = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            if format_name and first_token:
                self.engine.record_object(
                    name=format_name,
                    obj_type="FILE_FORMAT",
                    action="CREATE",
                    node=first_token,
                    file_path=self.current_file
                )
        # Extract TYPE and file format options
        type_value = None
        for child in tree.children:
            if isinstance(child, Token) and child.type == 'TYPE':
                type_value = child.value
            elif isinstance(child, Tree) and child.data == 'file_format_option_kv':
                for param in child.children:
                    if isinstance(param, Token) and param.type == 'FIELD_DELIMITER':
                        self.engine.record_object(
                            name=format_name,
                            obj_type="FILE_FORMAT",
                            action="FIELD_DELIMITER",
                            node=param,
                            file_path=self.current_file
                        )
        if type_value:
            self.engine.record_object(
                name=format_name,
                obj_type="FILE_FORMAT",
                action=f"TYPE_{type_value}",
                node=first_token,
                file_path=self.current_file
            )

    def copy_into_stmt(self, tree: Tree):
        """Visits `copy_into_stmt` nodes. Extracts source and target for COPY INTO, and options."""
        self._debug_tree(tree, "Copy Into Statement")

        copy_target_node = self._find_first_child_by_name(tree, 'copy_target')
        target_recorded = False
        target_name_str = None
        target_type = None
        target_node_for_loc = None

        if copy_target_node:
            qual_name_node = self._find_first_child_by_name(copy_target_node, 'qualified_name')
            stage_path_node = self._find_first_child_by_name(copy_target_node, 'STAGE_PATH')

            if qual_name_node:
                target_name_str = self._extract_qualified_name(qual_name_node)
                target_node_for_loc = next((t for t in qual_name_node.children if isinstance(t, Token)), None)
            elif stage_path_node:
                target_name_str = stage_path_node.children[0].value if stage_path_node.children else ""
                target_node_for_loc = stage_path_node
            
            if target_name_str and target_node_for_loc:
                # *** Determine target type based on name prefix ***
                if target_name_str.startswith('@'):
                    target_type = "STAGE"
                    self.engine.record_object(
                        name=target_name_str,
                        obj_type=target_type,
                        action="COPY_INTO_STAGE",
                        node=target_node_for_loc,
                        file_path=self.current_file
                    )
                    # Also record as a reference for source/target (if it's the target)
                    self.engine.record_object(
                        name=target_name_str,
                        obj_type=target_type,
                        action="REFERENCE",
                        node=target_node_for_loc,
                        file_path=self.current_file
                    )
                    # Also record the specific statement type
                    self.engine.record_statement("COPY_INTO_STAGE", tree, self.current_file)
                else:
                    target_type = "TABLE"
                    self.engine.record_object(
                        name=target_name_str,
                        obj_type=target_type,
                        action="COPY_INTO_TABLE",
                        node=target_node_for_loc,
                        file_path=self.current_file
                    )
                    # Also record the specific statement type
                    self.engine.record_statement("COPY_INTO_TABLE", tree, self.current_file)
                target_recorded = True
        
        if not target_recorded:
             logger.warning(f"Could not determine target (TABLE or STAGE) in COPY INTO statement: {tree.pretty()}")

        # --- Process Copy Source ---
        copy_source_node = self._find_first_child_by_name(tree, 'copy_source')
        if copy_source_node:
            source_qual_name_node = self._find_first_child_by_name(copy_source_node, 'qualified_name')
            source_stage_path_node = self._find_first_child_by_name(copy_source_node, 'STAGE_PATH')
            source_select_node = self._find_first_child_by_name(copy_source_node, 'select_stmt')

            source_name_str = None
            source_type = None
            source_node_for_loc = None

            if source_qual_name_node:
                source_name_str = self._extract_qualified_name(source_qual_name_node)
                source_node_for_loc = next((t for t in source_qual_name_node.children if isinstance(t, Token)), None)
            elif source_stage_path_node:
                source_name_str = source_stage_path_node.children[0].value if source_stage_path_node.children else ""
                source_node_for_loc = source_stage_path_node
            
            if source_name_str and source_node_for_loc:
                 # *** Determine source type based on name prefix ***
                 if source_name_str.startswith('@'):
                     source_type = "STAGE"
                 else:
                     source_type = "TABLE"
                 
                 self.engine.record_object(
                     name=source_name_str,
                     obj_type=source_type,
                     action="REFERENCE", # Source is referenced
                     node=source_node_for_loc,
                     file_path=self.current_file
                 )
            elif source_select_node:
                # If source is a subquery, visit it to find references within
                logger.debug("Descending into SELECT statement within COPY INTO source...")
                self.visit(source_select_node)

        # --- Process Copy Options (e.g., FILE_FORMAT reference) ---
        for child in tree.children:
            if isinstance(child, Tree) and child.data == 'copy_option':
                file_format_clause = self._find_first_child_by_name(child, 'file_format_clause')
                if file_format_clause:
                    # Look for a qualified_name (direct reference) first
                    ff_qual_name_node = self._find_first_child_by_name(file_format_clause, 'qualified_name')
                    if ff_qual_name_node:
                         file_format_name = self._extract_qualified_name(ff_qual_name_node)
                         first_token = next((t for t in ff_qual_name_node.children if isinstance(t, Token)), None)
                         if file_format_name and first_token:
                            self.engine.record_object(
                                name=file_format_name,
                                obj_type="FILE_FORMAT",
                                action="REFERENCE",
                                node=first_token,
                                file_path=self.current_file
                            )
                    else:
                        # Look for IDENTIFIER within file_format_option (inline definition case)
                        # This part might need refinement based on exact grammar for inline options
                        # Check if FORMAT_NAME = IDENTIFIER exists
                        for option_node in file_format_clause.find_data('file_format_option'):
                             # Assuming structure like: IDENTIFIER EQ (value | qualified_name)
                             id_token = None
                             val_token = None
                             eq_found = False
                             for item in option_node.children:
                                 if isinstance(item, Token) and item.type == 'IDENTIFIER':
                                     id_token = item
                                 elif isinstance(item, Token) and item.type == 'EQ':
                                     eq_found = True
                                 elif id_token and eq_found: # Value comes after ID and EQ
                                     if isinstance(item, Token) and item.type == 'IDENTIFIER': # Check if value is identifier
                                         val_token = item
                                         break
                                     # Might need to handle SINGLE_QUOTED_STRING too if FORMAT_NAME = 'name' is valid

                             if id_token and id_token.value.upper() == 'FORMAT_NAME' and val_token:
                                 file_format_name = val_token.value
                                 self.engine.record_object(
                                     name=file_format_name,
                                     obj_type="FILE_FORMAT",
                                     action="REFERENCE",
                                     node=val_token, # Use the token for the name
                                     file_path=self.current_file
                                 )
                                 break # Found the format name reference

        # Optionally, extract ON_ERROR etc. from other copy_option children

    # Add more specific visitor methods here for other statements/constructs
    # E.g., insert_stmt, merge_stmt, function calls, etc.

    # If a rule like `qualified_name`