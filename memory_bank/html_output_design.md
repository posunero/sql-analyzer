# Design Document: HTML Output for SQL Analyzer

## 1. Goal

To add a new output format to the SQL Analyzer that generates a single, self-contained HTML file. This report should be easily readable in any web browser and prioritize clarity and usefulness for developers reviewing the SQL analysis results.

## 2. Integration Strategy

The HTML output will be integrated into the existing reporting framework:

1.  **New Formatter Module:** Create a new file `sql_analyzer/reporting/formats/html.py`. This module will contain the primary function `format_html(result: AnalysisResult, **kwargs) -> str`.
2.  **Reporting Manager Update:** Register the new formatter in `sql_analyzer/reporting/manager.py` by adding an entry to the `_FORMATTERS` dictionary:
    ```python
    # In sql_analyzer/reporting/manager.py
    from .formats import text, json, html # Add html import

    _FORMATTERS = {
        'text': text.format_text,
        'json': json.format_json,
        'html': html.format_html, # Add this line
    }

    # Adjust generate_report if the html formatter needs specific args (e.g., verbose)
    # Currently, only 'text' uses verbose, so no change needed unless html requires it.
    ```
3.  **CLI Update:** Modify `sql_analyzer/cli.py` to:
    *   Add `'html'` to the `choices` list for the `--format` argument.
    *   Uncomment and potentially refine the `--output` argument to allow users to specify an output file path.
4.  **Main Workflow Update:** Modify `sql_analyzer/main.py` to handle the `--output` argument. If provided, write the report string generated by `reporting_manager.generate_report` to the specified file. Otherwise (or perhaps only for non-HTML formats), print to standard output.

## 3. Implementation Details (`html.py`)

1.  **Templating Engine:** Use the Jinja2 templating engine to generate the HTML. This separates the presentation logic (HTML structure, CSS) from the data processing logic (Python).
    *   **Dependency:** Add `Jinja2` to `requirements.txt`.
    *   **Template File:** Create a template file (e.g., `report_template.html.j2`) within the `sql_analyzer/reporting/formats/` directory or a dedicated `templates` subdirectory. The `format_html` function will load this template.
2.  **HTML Structure (Conceptual):** The generated HTML should include:
    *   **`<head>`:**
        *   `<meta charset="UTF-8">`
        *   `<title>SQL Analysis Report</title>`
        *   `<style>` tag containing all necessary CSS rules.
    *   **`<body>`:**
        *   **Header:** Report title, generation timestamp, maybe summary stats.
        *   **Summary Section:** Key metrics from `AnalysisResult` (e.g., total files processed, total statements, total errors). Display `statement_counts` and `destructive_counts`.
        *   **Errors Section:** A table listing all errors (`result.errors`) with columns for File, Line, and Message. Errors should be visually distinct (e.g., red text or background).
        *   **Object Interactions Section:** A primary table summarizing `result.object_interactions`. Columns: Object Type, Object Name, Actions (display the set of actions, e.g., `{CREATE, SELECT, DROP}`). Sort this table by Type, then Name for better readability.
        *   **(Optional) Detailed Object Occurrences:** A separate, possibly initially collapsed (`<details>` tag), section listing individual object occurrences from `result.objects_found`. Columns: File, Line, Column, Type, Name, Action. This provides traceability back to the source code.
        *   **(Optional) Footer:** Information about the analyzer tool.
3.  **Styling (Embedded CSS):**
    *   Keep CSS within the `<style>` tags in the `<head>` to ensure a single-file output.
    *   Focus on readability: good contrast, clear typography (sans-serif fonts), adequate spacing, distinct visual hierarchy.
    *   Use tables (`<table>`, `<thead>`, `<tbody>`, `<th>`, `<td>`) for tabular data. Style tables for clarity (e.g., borders, alternating row colors).
    *   Avoid large CSS frameworks (like Bootstrap/Tailwind) to minimize file size. Write simple, targeted CSS rules.
    *   Use semantic class names (e.g., `.error-message`, `.object-table`, `.summary-card`).
4.  **JavaScript (Minimal/Optional):**
    *   If desired, minimal embedded JavaScript (in `<script>` tags before `</body>`) could be used for features like client-side table sorting or toggling section visibility.
    *   Prioritize simplicity; vanilla JavaScript is preferred over frameworks to keep the file self-contained and lightweight. Start without JS unless strongly needed.

## 4. Data Representation in HTML

*   **`statement_counts` / `destructive_counts`:** Display as definition lists (`<dl>`) or simple tables in the Summary section.
*   **`errors`:** Display as a styled table (`<table>`). Make file paths/lines clear.
*   **`object_interactions`:** Display as the main analysis table (`<table>`), grouping actions per object.
*   **`objects_found`:** Display as a detailed table (`<table>`), potentially in a collapsed section, showing each specific finding.

## 5. Usage

The user would run the analyzer like this:

```bash
python -m sql_analyzer <input_paths...> --format html --output report.html
```

This generates the analysis report and saves it as `report.html` in the current directory.

```tool_code
print(default_api.edit_file(target_file='memory_bank/html_output.md', instructions='Create the design document for the HTML output feature.', code_edit='''# Design Document: HTML Output for SQL Analyzer

## 1. Goal

To add a new output format to the SQL Analyzer that generates a single, self-contained HTML file. This report should be easily readable in any web browser and prioritize clarity and usefulness for developers reviewing the SQL analysis results.

## 2. Integration Strategy

The HTML output will be integrated into the existing reporting framework:

1.  **New Formatter Module:** Create a new file `sql_analyzer/reporting/formats/html.py`. This module will contain the primary function `format_html(result: AnalysisResult, **kwargs) -> str`.
2.  **Reporting Manager Update:** Register the new formatter in `sql_analyzer/reporting/manager.py` by adding an entry to the `_FORMATTERS` dictionary:
    ```python
    # In sql_analyzer/reporting/manager.py
    from .formats import text, json, html # Add html import

    _FORMATTERS = {
        'text': text.format_text,
        'json': json.format_json,
        'html': html.format_html, # Add this line
    }

    # Adjust generate_report if the html formatter needs specific args (e.g., verbose)
    # Currently, only 'text' uses verbose, so no change needed unless html requires it.
    ```
3.  **CLI Update:** Modify `sql_analyzer/cli.py` to:
    *   Add `'html'` to the `choices` list for the `--format` argument.
    *   Uncomment and potentially refine the `--output` argument to allow users to specify an output file path.
4.  **Main Workflow Update:** Modify `sql_analyzer/main.py` to handle the `--output` argument. If provided, write the report string generated by `reporting_manager.generate_report` to the specified file. Otherwise (or perhaps only for non-HTML formats), print to standard output.

## 3. Implementation Details (`html.py`)

1.  **Templating Engine:** Use the Jinja2 templating engine to generate the HTML. This separates the presentation logic (HTML structure, CSS) from the data processing logic (Python).
    *   **Dependency:** Add `Jinja2` to `requirements.txt`.
    *   **Template File:** Create a template file (e.g., `report_template.html.j2`) within the `sql_analyzer/reporting/formats/` directory or a dedicated `templates` subdirectory. The `format_html` function will load this template.
2.  **HTML Structure (Conceptual):** The generated HTML should include:
    *   **`<head>`:**
        *   `<meta charset="UTF-8">`
        *   `<title>SQL Analysis Report</title>`
        *   `<style>` tag containing all necessary CSS rules.
    *   **`<body>`:**
        *   **Header:** Report title, generation timestamp, maybe summary stats.
        *   **Summary Section:** Key metrics from `AnalysisResult` (e.g., total files processed, total statements, total errors). Display `statement_counts` and `destructive_counts`.
        *   **Errors Section:** A table listing all errors (`result.errors`) with columns for File, Line, and Message. Errors should be visually distinct (e.g., red text or background).
        *   **Object Interactions Section:** A primary table summarizing `result.object_interactions`. Columns: Object Type, Object Name, Actions (display the set of actions, e.g., `{CREATE, SELECT, DROP}`). Sort this table by Type, then Name for better readability.
        *   **(Optional) Detailed Object Occurrences:** A separate, possibly initially collapsed (`<details>` tag), section listing individual object occurrences from `result.objects_found`. Columns: File, Line, Column, Type, Name, Action. This provides traceability back to the source code.
        *   **(Optional) Footer:** Information about the analyzer tool.
3.  **Styling (Embedded CSS):**
    *   Keep CSS within the `<style>` tags in the `<head>` to ensure a single-file output.
    *   Focus on readability: good contrast, clear typography (sans-serif fonts), adequate spacing, distinct visual hierarchy.
    *   Use tables (`<table>`, `<thead>`, `<tbody>`, `<th>`, `<td>`) for tabular data. Style tables for clarity (e.g., borders, alternating row colors).
    *   Avoid large CSS frameworks (like Bootstrap/Tailwind) to minimize file size. Write simple, targeted CSS rules.
    *   Use semantic class names (e.g., `.error-message`, `.object-table`, `.summary-card`).
4.  **JavaScript (Minimal/Optional):**
    *   If desired, minimal embedded JavaScript (in `<script>` tags before `</body>`) could be used for features like client-side table sorting or toggling section visibility.
    *   Prioritize simplicity; vanilla JavaScript is preferred over frameworks to keep the file self-contained and lightweight. Start without JS unless strongly needed.

## 4. Data Representation in HTML

*   **`statement_counts` / `destructive_counts`:** Display as definition lists (`<dl>`) or simple tables in the Summary section.
*   **`errors`:** Display as a styled table (`<table>`). Make file paths/lines clear.
*   **`object_interactions`:** Display as the main analysis table (`<table>`), grouping actions per object.
*   **`objects_found`:** Display as a detailed table (`<table>`), potentially in a collapsed section, showing each specific finding.

## 5. Usage

The user would run the analyzer like this:

```bash
python -m sql_analyzer <input_paths...> --format html --output report.html
```

This generates the analysis report and saves it as `report.html` in the current directory.
'''))